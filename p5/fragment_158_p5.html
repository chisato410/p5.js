<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <title>Eye Tracking</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/p5.js/1.7.0/p5.min.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/matter-js/0.19.0/matter.min.js"></script>
    <style>
      body {
        margin: 0;
        overflow: hidden;
        background-color: #000;
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100vh;
      }
      canvas {
        display: block;
      }
      .caption {
        position: absolute;
        left: 16px;
        bottom: 16px;
        color: #fff;
        font-family: Helvetica, Arial;
        z-index: 10;
        pointer-events: none;
      }
    </style>
  </head>
  <body>
    <div class="caption">“Eye Tracking”</div>
    <script>
      var Engine = Matter.Engine;
      var World = Matter.World;
      var Bodies = Matter.Bodies;
      var Mouse = Matter.Mouse;
      var MouseConstraint = Matter.MouseConstraint;

      let colors = "008dd5-dfbbb1-f56476-e43f6f-F7A072"
        .split("-")
        .map((a) => "#" + a);

      var engine;
      var world;
      var bodies = [];
      var mouseConstraint;
      let overAllTexture;

      function setup() {
        let canvas = createCanvas(800, 800);

        // テクスチャの生成
        overAllTexture = createGraphics(width, height);
        overAllTexture.loadPixels();
        for (var i = 0; i < width + 50; i++) {
          for (var o = 0; o < height + 50; o++) {
            overAllTexture.set(
              i,
              o,
              color(
                100,
                noise(i / 3, o / 10, (i * o) / 50) * random([0, 30, 60])
              )
            );
          }
        }
        overAllTexture.updatePixels();

        engine = Engine.create();
        world = engine.world;

        // マウス制御の設定
        var mouse = Mouse.create(canvas.elt);
        var mouseParams = {
          mouse: mouse,
          constraint: { stiffness: 0.1 },
        };
        mouseConstraint = MouseConstraint.create(engine, mouseParams);
        mouseConstraint.mouse.pixelRatio = pixelDensity();
        World.add(world, mouseConstraint);

        // 壁の作成
        var params = { isStatic: true };
        World.add(world, [
          Bodies.rectangle(width / 2, height, width, 50, params),
          Bodies.rectangle(0, height / 2, 50, height, params),
          Bodies.rectangle(width, height / 2, 50, height, params),
          Bodies.rectangle(width / 2, 0, width, 50, params),
        ]);

        // 円形キャラクターの生成
        function makeCircle(x, y) {
          var p = { restitution: 0.7, friction: 0.3 };
          let r = random(20, 60);
          let cir = Bodies.circle(x, y, r, p);
          cir.color = random(colors);
          cir.spots = [];
          for (var i = 0; i < 10; i++) {
            cir.spots.push({
              x: random(-0.8, 0.8) * random(),
              y: random(-0.8, 0.8) * random(),
              r: random(0, 0.5),
            });
          }
          return cir;
        }

        for (var i = 100; i < width; i += 150) {
          for (var o = 100; o < height; o += 120) {
            let cir = makeCircle(i, o);
            World.add(world, cir);
            bodies.push(cir);
          }
        }
      }

      function draw() {
        Engine.update(engine);
        background(20, 20, 80);

        for (var i = 0; i < bodies.length; i++) {
          var b = bodies[i];
          var pos = b.position;
          var r = b.circleRadius;
          var angle = b.angle;

          push();
          translate(pos.x, pos.y);
          rotate(angle);

          // 本体（トゲトゲ）の描画
          noStroke();
          fill(b.color);
          beginShape();
          let spanCount = 40;
          for (var o = 0; o < spanCount; o++) {
            let useR =
              (o % 4 < 2 ? r : r / 1.3) + sin(o + frameCount / 10 + i) * 3;
            let useAng = (o / spanCount) * PI * 2;
            vertex(useR * cos(useAng), useR * sin(useAng));
          }
          endShape(CLOSE);

          // スポット（模様）の描画
          fill(255, 40);
          b.spots.forEach((sp) => {
            ellipse(sp.x * r, sp.y * r, (sp.r * r) / 2);
          });

          // 口の描画
          noFill();
          stroke(0);
          let mouthR = (sin(frameCount / 5 + i) + 1) * (r / 6);
          if (b.active) {
            arc(0, r / 3, mouthR, mouthR, 0, TWO_PI);
          } else {
            arc(0, r / 3, r / 3, mouthR, PI, TWO_PI);
          }

          // --- 目の計算（ここからマウス反応） ---
          let angleToMouse = atan2(mouseY - pos.y, mouseX - pos.x);
          let distToMouse = dist(mouseX, mouseY, pos.x, pos.y);
          // 目が動く範囲を制限（白目からはみ出さないように）
          let eyeMoveLimit = r / 12;
          let lookX = cos(angleToMouse - angle) * eyeMoveLimit;
          let lookY = sin(angleToMouse - angle) * eyeMoveLimit;

          // まばたきアニメーション
          let isBlinking = (frameCount + i) % 120 < 5;
          let eyeH = isBlinking ? 0.05 : 1;

          push();
          scale(1, eyeH);

          // 白目
          noStroke();
          fill(255);
          let eyeSize = r / 2;
          let eyeOffX = r / 3;
          let eyeOffY = -r / 8;

          // active（掴まれている時）は目を見開く
          let eyeSpan = b.active ? TWO_PI : PI;
          arc(-eyeOffX, eyeOffY, eyeSize, eyeSize, 0, eyeSpan);
          arc(eyeOffX, eyeOffY, eyeSize, eyeSize, 0, eyeSpan);

          // 黒目（マウスの方向へオフセットを加える）
          fill(0);
          let pupilSize = r / 4;
          arc(
            -eyeOffX + lookX,
            eyeOffY + lookY,
            pupilSize,
            pupilSize,
            0,
            eyeSpan
          );
          arc(
            eyeOffX + lookX,
            eyeOffY + lookY,
            pupilSize,
            pupilSize,
            0,
            eyeSpan
          );
          pop();

          pop();
          b.active = false;
        }

        // マウスドラッグの線
        if (mouseConstraint.bodyB) {
          let bB = mouseConstraint.bodyB;
          let a = mouseConstraint.constraint.pointA;
          stroke(255, 50);
          line(a.x, a.y, bB.position.x, bB.position.y);
          bB.active = true;
          cursor("grab");
        } else {
          cursor(ARROW);
        }

        // 質感テクスチャ
        push();
        blendMode(MULTIPLY);
        image(overAllTexture, 0, 0);
        pop();
      }
    </script>
  </body>
</html>
