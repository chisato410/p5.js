<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Fragment #141 â€“ Fractal Tunnel</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
      body {
        margin: 0;
        background: #000000;
        overflow: hidden;
        height: 100vh;
      }

      .caption {
        position: fixed;
        left: 20px;
        bottom: 20px;
        font-family: "Helvetica Neue", sans-serif;
        font-size: 0.9rem;
        color: rgba(255, 255, 255, 0.9);
        z-index: 10;
        text-shadow: 0 2px 8px rgba(0, 255, 255, 0.8);
      }
    </style>
  </head>

  <body>
    <div class="caption">Fragment #141 â€“ "Fractal Tunnel" ğŸŒ€</div>

    <script>
      const scene = new THREE.Scene();

      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        200
      );
      camera.position.set(0, 0, 10);

      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);

      // ãƒˆãƒ³ãƒãƒ«ã®ãƒªãƒ³ã‚°
      const tunnelRings = [];

      function createTunnelRing(radius, depth, thickness, sides, hue) {
        const ring = new THREE.Group();

        // ãƒ¡ã‚¤ãƒ³ã®ãƒªãƒ³ã‚°
        const torusGeometry = new THREE.TorusGeometry(
          radius,
          thickness,
          16,
          sides
        );
        const color = new THREE.Color().setHSL(hue, 1, 0.5);
        const torusMaterial = new THREE.MeshBasicMaterial({
          color: color,
          transparent: true,
          opacity: 0.8,
          blending: THREE.AdditiveBlending,
          side: THREE.DoubleSide,
        });
        const torus = new THREE.Mesh(torusGeometry, torusMaterial);
        ring.add(torus);

        // ã‚¨ãƒƒã‚¸ã®ã‚°ãƒ­ãƒ¼
        const edgesGeometry = new THREE.EdgesGeometry(torusGeometry);
        const edgesMaterial = new THREE.LineBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0.6,
          blending: THREE.AdditiveBlending,
        });
        const edges = new THREE.LineSegments(edgesGeometry, edgesMaterial);
        ring.add(edges);

        // è£…é£¾ã®å°ã•ãªã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆ
        for (let i = 0; i < sides; i++) {
          const angle = (i / sides) * Math.PI * 2;
          const x = Math.cos(angle) * radius;
          const y = Math.sin(angle) * radius;

          const decorGeometry = new THREE.SphereGeometry(thickness * 1.5, 8, 8);
          const decorColor = new THREE.Color().setHSL((hue + 0.1) % 1, 1, 0.6);
          const decorMaterial = new THREE.MeshBasicMaterial({
            color: decorColor,
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending,
          });
          const decor = new THREE.Mesh(decorGeometry, decorMaterial);
          decor.position.set(x, y, 0);
          ring.add(decor);
        }

        ring.position.z = depth;

        ring.userData = {
          initialZ: depth,
          hue: hue,
          radius: radius,
          rotateSpeed: 0.5 + Math.random() * 1,
        };

        return ring;
      }

      // ãƒˆãƒ³ãƒãƒ«ã‚’ä½œæˆ
      const ringCount = 50;
      for (let i = 0; i < ringCount; i++) {
        const depth = -i * 10;
        const radius = 3 + Math.sin(i * 0.3) * 2;
        const thickness = 0.1 + Math.sin(i * 0.5) * 0.1;
        const sides = 6 + (i % 4) * 2;
        const hue = (i / ringCount) % 1;

        const ring = createTunnelRing(radius, depth, thickness, sides, hue);
        scene.add(ring);
        tunnelRings.push(ring);
      }

      // ãƒ•ãƒ©ã‚¯ã‚¿ãƒ«çŠ¶ã®åˆ†å²
      const branches = [];

      function createBranch(startZ, angle) {
        const branch = new THREE.Group();

        for (let i = 0; i < 10; i++) {
          const sphereGeometry = new THREE.SphereGeometry(0.3, 8, 8);
          const hue = ((startZ + i) / 100) % 1;
          const color = new THREE.Color().setHSL(hue, 1, 0.5);
          const material = new THREE.MeshBasicMaterial({
            color: color,
            transparent: true,
            opacity: 0.7,
            blending: THREE.AdditiveBlending,
          });
          const sphere = new THREE.Mesh(sphereGeometry, material);

          const distance = 4 + i * 0.8;
          sphere.position.x = Math.cos(angle) * distance;
          sphere.position.y = Math.sin(angle) * distance;
          sphere.position.z = startZ - i * 5;

          sphere.userData = {
            hue: hue,
            pulseSpeed: 2 + Math.random() * 2,
            pulseOffset: Math.random() * Math.PI * 2,
          };

          branch.add(sphere);
        }

        return branch;
      }

      for (let i = 0; i < 8; i++) {
        const angle = (i / 8) * Math.PI * 2;
        const startZ = -i * 30;
        const branch = createBranch(startZ, angle);
        scene.add(branch);
        branches.push(branch);
      }

      // å…‰ã®è»Œè·¡
      const trailGeometry = new THREE.BufferGeometry();
      const trailCount = 500;
      const trailPositions = new Float32Array(trailCount * 3);
      const trailColors = new Float32Array(trailCount * 3);

      for (let i = 0; i < trailCount; i++) {
        const i3 = i * 3;

        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * 6;
        trailPositions[i3] = Math.cos(angle) * radius;
        trailPositions[i3 + 1] = Math.sin(angle) * radius;
        trailPositions[i3 + 2] = -Math.random() * 300;

        const hue = Math.random();
        const color = new THREE.Color().setHSL(hue, 1, 0.5);
        trailColors[i3] = color.r;
        trailColors[i3 + 1] = color.g;
        trailColors[i3 + 2] = color.b;
      }

      trailGeometry.setAttribute(
        "position",
        new THREE.BufferAttribute(trailPositions, 3)
      );
      trailGeometry.setAttribute(
        "color",
        new THREE.BufferAttribute(trailColors, 3)
      );

      const trailMaterial = new THREE.PointsMaterial({
        size: 0.2,
        vertexColors: true,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending,
      });

      const trail = new THREE.Points(trailGeometry, trailMaterial);
      scene.add(trail);

      // ãƒ©ã‚¤ãƒˆ
      const lights = [];
      for (let i = 0; i < 4; i++) {
        const hue = i / 4;
        const color = new THREE.Color().setHSL(hue, 1, 0.5);
        const light = new THREE.PointLight(color, 3, 30);
        light.position.z = -50 - i * 50;
        scene.add(light);
        lights.push(light);
      }

      function animate() {
        requestAnimationFrame(animate);

        const t = performance.now() * 0.001;

        // ãƒˆãƒ³ãƒãƒ«ãƒªãƒ³ã‚°ã®å‹•ã
        tunnelRings.forEach((ring, index) => {
          const data = ring.userData;

          // å‰æ–¹ã«ç§»å‹•
          ring.position.z += 0.5;

          // å¾Œã‚ã‹ã‚‰å‰ã«å¾ªç’°
          if (ring.position.z > 10) {
            ring.position.z = -ringCount * 10;
          }

          // å›è»¢
          ring.rotation.z += data.rotateSpeed * 0.02;

          // è‰²ã®å¤‰åŒ–
          const hue = (data.hue + t * 0.1) % 1;
          const color = new THREE.Color().setHSL(hue, 1, 0.5);

          if (ring.children[0]) {
            ring.children[0].material.color.copy(color);
          }

          // è£…é£¾ã‚ªãƒ–ã‚¸ã‚§ã‚¯ãƒˆã®è„ˆå‹•
          for (let i = 2; i < ring.children.length; i++) {
            const decor = ring.children[i];
            const pulse = Math.sin(t * 3 + index + i) * 0.5 + 0.5;
            decor.scale.setScalar(1 + pulse * 0.5);

            const decorHue = (hue + 0.1) % 1;
            const decorColor = new THREE.Color().setHSL(decorHue, 1, 0.6);
            decor.material.color.copy(decorColor);
          }
        });

        // åˆ†å²ã®å‹•ã
        branches.forEach((branch) => {
          branch.position.z += 0.3;

          if (branch.position.z > 10) {
            branch.position.z = -300;
          }

          branch.children.forEach((sphere) => {
            const data = sphere.userData;
            const pulse =
              Math.sin(t * data.pulseSpeed + data.pulseOffset) * 0.5 + 0.5;
            sphere.scale.setScalar(1 + pulse * 0.5);

            const hue = (data.hue + t * 0.1) % 1;
            const color = new THREE.Color().setHSL(hue, 1, 0.5);
            sphere.material.color.copy(color);
          });
        });

        // å…‰ã®è»Œè·¡
        const trailPos = trailGeometry.attributes.position.array;
        const trailCol = trailGeometry.attributes.color.array;

        for (let i = 0; i < trailCount; i++) {
          const i3 = i * 3;

          trailPos[i3 + 2] += 1;

          if (trailPos[i3 + 2] > 10) {
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.random() * 6;
            trailPos[i3] = Math.cos(angle) * radius;
            trailPos[i3 + 1] = Math.sin(angle) * radius;
            trailPos[i3 + 2] = -300;
          }

          // è‰²ã®å¤‰åŒ–
          const hue = (t * 0.2 + i * 0.01) % 1;
          const color = new THREE.Color().setHSL(hue, 1, 0.5);
          trailCol[i3] = color.r;
          trailCol[i3 + 1] = color.g;
          trailCol[i3 + 2] = color.b;
        }
        trailGeometry.attributes.position.needsUpdate = true;
        trailGeometry.attributes.color.needsUpdate = true;

        // ãƒ©ã‚¤ãƒˆã®å‹•ã
        lights.forEach((light, index) => {
          light.position.z += 0.5;

          if (light.position.z > 10) {
            light.position.z = -200;
          }

          const angle = t + (index * Math.PI) / 2;
          light.position.x = Math.cos(angle) * 5;
          light.position.y = Math.sin(angle) * 5;

          const hue = (t * 0.1 + index / 4) % 1;
          light.color.setHSL(hue, 1, 0.5);
        });

        // ã‚«ãƒ¡ãƒ©ã®æºã‚Œ
        camera.position.x = Math.sin(t * 0.5) * 0.5;
        camera.position.y = Math.cos(t * 0.7) * 0.5;
        camera.rotation.z = Math.sin(t * 0.3) * 0.05;

        renderer.render(scene, camera);
      }
      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
