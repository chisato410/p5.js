<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Fragment #137 ‚Äì Nebula</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
      body {
        margin: 0;
        background: #000000;
        overflow: hidden;
        height: 100vh;
      }

      .caption {
        position: fixed;
        left: 20px;
        bottom: 20px;
        font-family: "Helvetica Neue", sans-serif;
        font-size: 0.9rem;
        color: rgba(255, 150, 200, 0.9);
        z-index: 10;
        text-shadow: 0 2px 8px rgba(255, 100, 200, 0.8);
      }
    </style>
  </head>

  <body>
    <div class="caption">Fragment #137 ‚Äì "Nebula" üå†</div>

    <script>
      const scene = new THREE.Scene();

      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        300
      );
      camera.position.set(0, 0, 50);

      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);

      // ÊòüÈõ≤„ÅÆ„Ç¨„ÇπÈõ≤„Çí‰ΩúÊàê
      function createNebulaCloud(particleCount, color, size, spread) {
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const colors = new Float32Array(particleCount * 3);
        const sizes = new Float32Array(particleCount);

        const baseColor = new THREE.Color(color);

        for (let i = 0; i < particleCount; i++) {
          const i3 = i * 3;

          // ÁêÉÁä∂„Å´ÂàÜÂ∏É
          const theta = Math.random() * Math.PI * 2;
          const phi = Math.acos(Math.random() * 2 - 1);
          const radius = Math.random() * spread;

          positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
          positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
          positions[i3 + 2] = radius * Math.cos(phi);

          // Ëâ≤„ÅÆÂ§âÂåñ
          const colorVariation = 0.3 + Math.random() * 0.7;
          colors[i3] = baseColor.r * colorVariation;
          colors[i3 + 1] = baseColor.g * colorVariation;
          colors[i3 + 2] = baseColor.b * colorVariation;

          sizes[i] = Math.random() * size + size * 0.5;
        }

        geometry.setAttribute(
          "position",
          new THREE.BufferAttribute(positions, 3)
        );
        geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));
        geometry.setAttribute("size", new THREE.BufferAttribute(sizes, 1));

        const material = new THREE.PointsMaterial({
          size: size,
          vertexColors: true,
          transparent: true,
          opacity: 0.6,
          blending: THREE.AdditiveBlending,
          depthWrite: false,
          sizeAttenuation: true,
        });

        return new THREE.Points(geometry, material);
      }

      // Ë§áÊï∞„ÅÆÊòüÈõ≤Â±§
      const nebulaClouds = [];
      const nebulaConfigs = [
        { count: 3000, color: 0xff006e, size: 3, spread: 40 },
        { count: 2500, color: 0x8338ec, size: 3.5, spread: 35 },
        { count: 2000, color: 0x3a86ff, size: 2.5, spread: 30 },
        { count: 1800, color: 0xfb5607, size: 4, spread: 38 },
        { count: 2200, color: 0xff006e, size: 2, spread: 25 },
      ];

      nebulaConfigs.forEach((config) => {
        const cloud = createNebulaCloud(
          config.count,
          config.color,
          config.size,
          config.spread
        );

        cloud.userData = {
          rotateSpeedX: (Math.random() - 0.5) * 0.0005,
          rotateSpeedY: (Math.random() - 0.5) * 0.0008,
          rotateSpeedZ: (Math.random() - 0.5) * 0.0003,
        };

        scene.add(cloud);
        nebulaClouds.push(cloud);
      });

      // Êòé„Çã„ÅÑÊòü
      const brightStarsGeometry = new THREE.BufferGeometry();
      const brightStarsCount = 100;
      const brightStarsPositions = new Float32Array(brightStarsCount * 3);
      const brightStarsColors = new Float32Array(brightStarsCount * 3);
      const brightStarsSizes = new Float32Array(brightStarsCount);

      for (let i = 0; i < brightStarsCount; i++) {
        const i3 = i * 3;

        brightStarsPositions[i3] = (Math.random() - 0.5) * 100;
        brightStarsPositions[i3 + 1] = (Math.random() - 0.5) * 100;
        brightStarsPositions[i3 + 2] = (Math.random() - 0.5) * 100;

        const colors = [0xffffff, 0xaaccff, 0xffccaa, 0xccaaff];
        const color = new THREE.Color(
          colors[Math.floor(Math.random() * colors.length)]
        );
        brightStarsColors[i3] = color.r;
        brightStarsColors[i3 + 1] = color.g;
        brightStarsColors[i3 + 2] = color.b;

        brightStarsSizes[i] = Math.random() * 4 + 2;
      }

      brightStarsGeometry.setAttribute(
        "position",
        new THREE.BufferAttribute(brightStarsPositions, 3)
      );
      brightStarsGeometry.setAttribute(
        "color",
        new THREE.BufferAttribute(brightStarsColors, 3)
      );
      brightStarsGeometry.setAttribute(
        "size",
        new THREE.BufferAttribute(brightStarsSizes, 1)
      );

      const brightStarsMaterial = new THREE.PointsMaterial({
        size: 2,
        vertexColors: true,
        transparent: true,
        opacity: 0.9,
        blending: THREE.AdditiveBlending,
        sizeAttenuation: true,
      });

      const brightStars = new THREE.Points(
        brightStarsGeometry,
        brightStarsMaterial
      );
      scene.add(brightStars);

      // ËÉåÊôØ„ÅÆÊòü
      const backgroundStarsGeometry = new THREE.BufferGeometry();
      const backgroundStarsCount = 2000;
      const backgroundStarsPositions = new Float32Array(
        backgroundStarsCount * 3
      );

      for (let i = 0; i < backgroundStarsCount; i++) {
        const i3 = i * 3;

        const theta = Math.random() * Math.PI * 2;
        const phi = Math.acos(Math.random() * 2 - 1);
        const radius = 100 + Math.random() * 100;

        backgroundStarsPositions[i3] = radius * Math.sin(phi) * Math.cos(theta);
        backgroundStarsPositions[i3 + 1] =
          radius * Math.sin(phi) * Math.sin(theta);
        backgroundStarsPositions[i3 + 2] = radius * Math.cos(phi);
      }

      backgroundStarsGeometry.setAttribute(
        "position",
        new THREE.BufferAttribute(backgroundStarsPositions, 3)
      );

      const backgroundStarsMaterial = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.5,
        transparent: true,
        opacity: 0.6,
      });

      const backgroundStars = new THREE.Points(
        backgroundStarsGeometry,
        backgroundStarsMaterial
      );
      scene.add(backgroundStars);

      // ÊòüÈõ≤„ÅÆ‰∏≠ÂøÉ„ÅÆÊòé„Çã„ÅÑ„Ç≥„Ç¢
      const coreGeometry = new THREE.SphereGeometry(5, 32, 32);
      const coreMaterial = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.3,
        blending: THREE.AdditiveBlending,
      });
      const core = new THREE.Mesh(coreGeometry, coreMaterial);
      scene.add(core);

      // „Ç∞„É≠„Éº„Ç®„Éï„Çß„ÇØ„Éà
      const glowGeometry = new THREE.SphereGeometry(8, 32, 32);
      const glowMaterial = new THREE.MeshBasicMaterial({
        color: 0xff88cc,
        transparent: true,
        opacity: 0.15,
        blending: THREE.AdditiveBlending,
      });
      const glow = new THREE.Mesh(glowGeometry, glowMaterial);
      scene.add(glow);

      // „É©„Ç§„Éà
      const light1 = new THREE.PointLight(0xff006e, 3, 80);
      light1.position.set(0, 0, 0);
      scene.add(light1);

      const light2 = new THREE.PointLight(0x3a86ff, 2, 60);
      light2.position.set(20, 10, 10);
      scene.add(light2);

      const light3 = new THREE.PointLight(0x8338ec, 2, 60);
      light3.position.set(-20, -10, -10);
      scene.add(light3);

      function animate() {
        requestAnimationFrame(animate);

        const t = performance.now() * 0.001;

        // ÊòüÈõ≤„ÅÆÂõûËª¢
        nebulaClouds.forEach((cloud) => {
          const data = cloud.userData;
          cloud.rotation.x += data.rotateSpeedX;
          cloud.rotation.y += data.rotateSpeedY;
          cloud.rotation.z += data.rotateSpeedZ;

          // „Ç¨„ÇπÈõ≤„ÅÆËÑàÂãï
          const positions = cloud.geometry.attributes.position.array;
          const originalPositions = cloud.geometry.attributes.position.array;

          for (let i = 0; i < positions.length; i += 3) {
            const x = positions[i];
            const y = positions[i + 1];
            const z = positions[i + 2];
            const distance = Math.sqrt(x * x + y * y + z * z);

            const pulse = Math.sin(t * 0.5 + distance * 0.1) * 0.05 + 1;
            positions[i] = x * pulse;
            positions[i + 1] = y * pulse;
            positions[i + 2] = z * pulse;
          }
          cloud.geometry.attributes.position.needsUpdate = true;
        });

        // Êòé„Çã„ÅÑÊòü„ÅÆ„Åç„Çâ„ÇÅ„Åç
        const brightStarsPos = brightStarsGeometry.attributes.position.array;
        for (let i = 0; i < brightStarsCount; i++) {
          const i3 = i * 3;
          const twinkle = Math.sin(t * 2 + i * 0.5) * 0.1;

          brightStarsPos[i3] += twinkle;
          brightStarsPos[i3 + 1] += Math.cos(t * 1.5 + i * 0.3) * 0.1;
        }
        brightStarsGeometry.attributes.position.needsUpdate = true;

        // „Ç≥„Ç¢„ÅÆËÑàÂãï
        const corePulse = Math.sin(t * 0.8) * 0.5 + 0.5;
        core.scale.setScalar(1 + corePulse * 0.3);
        coreMaterial.opacity = 0.2 + corePulse * 0.15;

        glow.scale.setScalar(1 + corePulse * 0.2);
        glowMaterial.opacity = 0.1 + corePulse * 0.1;

        // „É©„Ç§„Éà„ÅÆÂãï„Åç
        light1.intensity = 2.5 + corePulse * 1;

        light2.position.x = Math.cos(t * 0.3) * 25;
        light2.position.y = Math.sin(t * 0.4) * 20;
        light2.position.z = Math.sin(t * 0.2) * 15;

        light3.position.x = Math.cos(t * 0.35 + Math.PI) * 25;
        light3.position.y = Math.sin(t * 0.45 + Math.PI) * 20;
        light3.position.z = Math.cos(t * 0.25 + Math.PI) * 15;

        // ËÉåÊôØ„ÅÆÊòü„ÅÆÂõûËª¢
        backgroundStars.rotation.y += 0.0001;
        backgroundStars.rotation.x += 0.00005;

        // „Ç´„É°„É©„ÅÆÂãï„Åç
        camera.position.x = Math.sin(t * 0.05) * 60;
        camera.position.y = Math.cos(t * 0.07) * 40;
        camera.position.z = 50 + Math.cos(t * 0.06) * 20;
        camera.lookAt(0, 0, 0);

        renderer.render(scene, camera);
      }
      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
