<!-- fragment_028_three.html -->
<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Fragment #129 ‚Äì Dreamy Carousel</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
      body {
        margin: 0;
        background: linear-gradient(
          180deg,
          #ffd6e7 0%,
          #ffe8f0 50%,
          #fff5e6 100%
        );
        overflow: hidden;
        height: 100vh;
      }

      .caption {
        position: fixed;
        left: 20px;
        bottom: 20px;
        font-family: "Helvetica Neue", sans-serif;
        font-size: 0.9rem;
        color: rgba(200, 100, 150, 0.9);
        z-index: 10;
        text-shadow: 0 2px 4px rgba(255, 255, 255, 0.8);
      }
    </style>
  </head>

  <body>
    <div class="caption">Fragment #129 ‚Äì "Dreamy Carousel" üé†</div>

    <script>
      const scene = new THREE.Scene();

      const camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        100
      );
      camera.position.set(0, 5, 15);

      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);

      // „É©„Ç§„ÉÜ„Ç£„É≥„Ç∞
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
      scene.add(ambientLight);

      const light1 = new THREE.PointLight(0xffb3d9, 1, 40);
      light1.position.set(5, 8, 5);
      scene.add(light1);

      const light2 = new THREE.PointLight(0xb3d9ff, 1, 40);
      light2.position.set(-5, 8, -5);
      scene.add(light2);

      // „É°„É™„Éº„Ç¥„Éº„É©„É≥„ÉâÂÖ®‰Ωì„ÅÆ„Ç∞„É´„Éº„Éó
      const carousel = new THREE.Group();

      // Â±ãÊ†π
      const roofGeometry = new THREE.ConeGeometry(6, 3, 8);
      const roofMaterial = new THREE.MeshPhongMaterial({
        color: 0xff69b4,
        shininess: 80,
        emissive: 0xff1493,
        emissiveIntensity: 0.2,
      });
      const roof = new THREE.Mesh(roofGeometry, roofMaterial);
      roof.position.y = 5;
      carousel.add(roof);

      // Â±ãÊ†π„ÅÆÁ∏Å„ÅÆË£ÖÈ£æ
      const roofTrimGeometry = new THREE.TorusGeometry(6, 0.2, 16, 32);
      const roofTrimMaterial = new THREE.MeshPhongMaterial({
        color: 0xffd700,
        shininess: 100,
      });
      const roofTrim = new THREE.Mesh(roofTrimGeometry, roofTrimMaterial);
      roofTrim.rotation.x = Math.PI / 2;
      roofTrim.position.y = 3.5;
      carousel.add(roofTrim);

      // ‰∏≠Â§Æ„ÅÆ„Éù„Éº„É´
      const poleGeometry = new THREE.CylinderGeometry(0.3, 0.3, 8, 16);
      const poleMaterial = new THREE.MeshPhongMaterial({
        color: 0xffd700,
        shininess: 100,
        emissive: 0xffaa00,
        emissiveIntensity: 0.3,
      });
      const pole = new THREE.Mesh(poleGeometry, poleMaterial);
      pole.position.y = 2;
      carousel.add(pole);

      // Â∫ä„ÅÆ„Éó„É©„ÉÉ„Éà„Éï„Ç©„Éº„É†
      const platformGeometry = new THREE.CylinderGeometry(7, 7, 0.5, 32);
      const platformMaterial = new THREE.MeshPhongMaterial({
        color: 0xffb6c1,
        shininess: 60,
      });
      const platform = new THREE.Mesh(platformGeometry, platformMaterial);
      platform.position.y = -0.5;
      carousel.add(platform);

      // „Éó„É©„ÉÉ„Éà„Éï„Ç©„Éº„É†„ÅÆÁ∏Å
      const edgeGeometry = new THREE.TorusGeometry(7, 0.3, 16, 32);
      const edgeMaterial = new THREE.MeshPhongMaterial({
        color: 0xff1493,
        shininess: 80,
      });
      const edge = new THREE.Mesh(edgeGeometry, edgeMaterial);
      edge.rotation.x = Math.PI / 2;
      edge.position.y = -0.25;
      carousel.add(edge);

      // Êú®È¶¨„Çí‰Ωú„ÇãÈñ¢Êï∞
      function createHorse(color) {
        const horse = new THREE.Group();

        // ËÉ¥‰Ωì
        const bodyGeometry = new THREE.SphereGeometry(0.8, 16, 16);
        bodyGeometry.scale(1.5, 1, 1);
        const bodyMaterial = new THREE.MeshPhongMaterial({
          color: color,
          shininess: 60,
        });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        body.position.y = 1;
        horse.add(body);

        // È¶ñ
        const neckGeometry = new THREE.CylinderGeometry(0.3, 0.4, 1, 16);
        const neck = new THREE.Mesh(neckGeometry, bodyMaterial);
        neck.position.set(0.8, 1.5, 0);
        neck.rotation.z = -0.5;
        horse.add(neck);

        // È†≠
        const headGeometry = new THREE.SphereGeometry(0.5, 16, 16);
        headGeometry.scale(1, 1.2, 0.8);
        const head = new THREE.Mesh(headGeometry, bodyMaterial);
        head.position.set(1.3, 2.2, 0);
        horse.add(head);

        // „Åü„Å¶„Åå„Åø
        const maneColor = color === 0xffffff ? 0xffb6c1 : 0xffd700;
        const maneGeometry = new THREE.SphereGeometry(0.3, 8, 8);
        const maneMaterial = new THREE.MeshPhongMaterial({
          color: maneColor,
          shininess: 40,
        });

        for (let i = 0; i < 4; i++) {
          const manePart = new THREE.Mesh(maneGeometry, maneMaterial);
          manePart.position.set(0.8 + i * 0.15, 1.8 + i * 0.15, 0);
          horse.add(manePart);
        }

        // ËÄ≥
        const earGeometry = new THREE.ConeGeometry(0.1, 0.3, 8);
        const leftEar = new THREE.Mesh(earGeometry, bodyMaterial);
        leftEar.position.set(1.2, 2.6, -0.2);
        leftEar.rotation.z = -0.3;
        horse.add(leftEar);

        const rightEar = new THREE.Mesh(earGeometry, bodyMaterial);
        rightEar.position.set(1.2, 2.6, 0.2);
        rightEar.rotation.z = -0.3;
        horse.add(rightEar);

        // ÁõÆ
        const eyeGeometry = new THREE.SphereGeometry(0.08, 8, 8);
        const eyeMaterial = new THREE.MeshPhongMaterial({
          color: 0x000000,
          shininess: 100,
        });
        const eye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        eye.position.set(1.5, 2.3, 0.3);
        horse.add(eye);

        // Ë∂≥
        const legGeometry = new THREE.CylinderGeometry(0.15, 0.15, 1.5, 8);
        const positions = [
          [-0.4, 0.25, -0.4],
          [-0.4, 0.25, 0.4],
          [0.4, 0.25, -0.4],
          [0.4, 0.25, 0.4],
        ];

        positions.forEach((pos) => {
          const leg = new THREE.Mesh(legGeometry, bodyMaterial);
          leg.position.set(pos[0], pos[1], pos[2]);
          horse.add(leg);
        });

        // „Çµ„Éâ„É´
        const saddleGeometry = new THREE.SphereGeometry(0.6, 16, 16);
        saddleGeometry.scale(1, 0.3, 1);
        const saddleMaterial = new THREE.MeshPhongMaterial({
          color: 0x8b4513,
          shininess: 30,
        });
        const saddle = new THREE.Mesh(saddleGeometry, saddleMaterial);
        saddle.position.set(0, 1.5, 0);
        horse.add(saddle);

        return horse;
      }

      // Êú®È¶¨„Åü„Å°
      const horses = [];
      const horseColors = [
        0xffffff, 0xffb6c1, 0xffd700, 0xb3d9ff, 0xffb3d9, 0xd9b3ff,
      ];

      for (let i = 0; i < 6; i++) {
        const horse = createHorse(horseColors[i]);

        const angle = (i / 6) * Math.PI * 2;
        const radius = 4.5;
        horse.position.x = Math.cos(angle) * radius;
        horse.position.z = Math.sin(angle) * radius;
        horse.position.y = 0.5;

        horse.rotation.y = -angle + Math.PI / 2;

        // „Éù„Éº„É´„Å´Áπã„Åå„ÇãÊ£í
        const poleConnectorGeometry = new THREE.CylinderGeometry(
          0.08,
          0.08,
          4,
          8
        );
        const poleConnectorMaterial = new THREE.MeshPhongMaterial({
          color: 0xffd700,
          shininess: 100,
        });
        const poleConnector = new THREE.Mesh(
          poleConnectorGeometry,
          poleConnectorMaterial
        );
        poleConnector.position.set(0, 2.5, 0);
        horse.add(poleConnector);

        horse.userData = {
          bobSpeed: 0.8 + i * 0.1,
          bobAmount: 0.4,
          bobOffset: (i * Math.PI) / 3,
        };

        carousel.add(horse);
        horses.push(horse);
      }

      // Ë£ÖÈ£æ„É©„Ç§„Éà
      const decorativeLights = [];
      for (let i = 0; i < 16; i++) {
        const angle = (i / 16) * Math.PI * 2;
        const lightGeometry = new THREE.SphereGeometry(0.15, 16, 16);
        const lightMaterial = new THREE.MeshBasicMaterial({
          color: i % 2 === 0 ? 0xffd700 : 0xff69b4,
          transparent: true,
          opacity: 0.9,
        });
        const light = new THREE.Mesh(lightGeometry, lightMaterial);

        light.position.x = Math.cos(angle) * 5.5;
        light.position.z = Math.sin(angle) * 5.5;
        light.position.y = 3.5;

        light.userData = {
          twinkleSpeed: 2 + Math.random(),
          twinkleOffset: i,
        };

        carousel.add(light);
        decorativeLights.push(light);
      }

      scene.add(carousel);
      carousel.position.y = -1;

      // Á¥ôÂêπÈõ™
      const confettiGeometry = new THREE.BufferGeometry();
      const confettiCount = 150;
      const confettiPositions = new Float32Array(confettiCount * 3);
      const confettiColors = new Float32Array(confettiCount * 3);

      for (let i = 0; i < confettiCount; i++) {
        const i3 = i * 3;

        confettiPositions[i3] = (Math.random() - 0.5) * 25;
        confettiPositions[i3 + 1] = Math.random() * 15;
        confettiPositions[i3 + 2] = (Math.random() - 0.5) * 25;

        const colors = [0xff69b4, 0xffd700, 0xb3d9ff, 0xffb3d9];
        const color = new THREE.Color(
          colors[Math.floor(Math.random() * colors.length)]
        );
        confettiColors[i3] = color.r;
        confettiColors[i3 + 1] = color.g;
        confettiColors[i3 + 2] = color.b;
      }

      confettiGeometry.setAttribute(
        "position",
        new THREE.BufferAttribute(confettiPositions, 3)
      );
      confettiGeometry.setAttribute(
        "color",
        new THREE.BufferAttribute(confettiColors, 3)
      );

      const confettiMaterial = new THREE.PointsMaterial({
        size: 0.2,
        vertexColors: true,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending,
      });

      const confetti = new THREE.Points(confettiGeometry, confettiMaterial);
      scene.add(confetti);

      function animate() {
        requestAnimationFrame(animate);

        const t = performance.now() * 0.001;

        // „É°„É™„Éº„Ç¥„Éº„É©„É≥„ÉâÂÖ®‰Ωì„ÅÆÂõûËª¢
        carousel.rotation.y = t * 0.3;

        // Êú®È¶¨„ÅÆ‰∏ä‰∏ãÈÅãÂãï
        horses.forEach((horse) => {
          const data = horse.userData;
          const bob = Math.sin(t * data.bobSpeed + data.bobOffset);
          horse.position.y = 0.5 + bob * data.bobAmount;
        });

        // Ë£ÖÈ£æ„É©„Ç§„Éà„ÅÆÁÇπÊªÖ
        decorativeLights.forEach((light) => {
          const data = light.userData;
          const twinkle =
            Math.sin(t * data.twinkleSpeed + data.twinkleOffset) * 0.5 + 0.5;
          light.material.opacity = 0.5 + twinkle * 0.5;

          const scale = 1 + twinkle * 0.3;
          light.scale.set(scale, scale, scale);
        });

        // Á¥ôÂêπÈõ™„ÅÆÂãï„Åç
        const confettiPos = confettiGeometry.attributes.position.array;
        for (let i = 0; i < confettiCount; i++) {
          const i3 = i * 3;
          confettiPos[i3 + 1] -= 0.02;
          confettiPos[i3] += Math.sin(t + i) * 0.02;

          if (confettiPos[i3 + 1] < -5) {
            confettiPos[i3 + 1] = 15;
          }
        }
        confettiGeometry.attributes.position.needsUpdate = true;

        // „Ç´„É°„É©„ÅÆÂãï„Åç
        camera.position.x = Math.sin(t * 0.15) * 3;
        camera.position.z = Math.cos(t * 0.15) * 15;
        camera.position.y = 5 + Math.sin(t * 0.1) * 1;
        camera.lookAt(0, 0, 0);

        renderer.render(scene, camera);
      }
      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
