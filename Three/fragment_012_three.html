<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Fragment #115 – GLSL Shader Art</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
      body {
        margin: 0;
        background: #000;
        overflow: hidden;
        height: 100vh;
      }

      .caption {
        position: fixed;
        left: 20px;
        bottom: 20px;
        font-family: "Helvetica Neue", sans-serif;
        font-size: 0.9rem;
        color: rgba(255, 255, 255, 0.75);
        z-index: 10;
      }
    </style>
  </head>

  <body>
    <div class="caption">Fragment #115 – "GLSL Shader Art"</div>

    <script>
      const scene = new THREE.Scene();

      const camera = new THREE.OrthographicCamera(-1, 1, 1, -1, 0, 1);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);

      // カスタムシェーダーマテリアル
      const vertexShader = `
        varying vec2 vUv;

        void main() {
          vUv = uv;
          gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);
        }
      `;

      const fragmentShader = `
        uniform float u_time;
        uniform vec2 u_resolution;
        varying vec2 vUv;

        // 回転行列
        mat2 rot(float a) {
          float c = cos(a);
          float s = sin(a);
          return mat2(c, -s, s, c);
        }

        // SDFサークル
        float sdCircle(vec2 p, float r) {
          return length(p) - r;
        }

        // SDFボックス
        float sdBox(vec2 p, vec2 b) {
          vec2 d = abs(p) - b;
          return length(max(d, 0.0)) + min(max(d.x, d.y), 0.0);
        }

        // フラクタルパターン
        float fractalPattern(vec2 uv, float time) {
          float d = 0.0;
          vec2 p = uv;

          for (int i = 0; i < 5; i++) {
            float fi = float(i);
            p = abs(p) - 0.5;
            p *= rot(time * 0.2 + fi * 0.5);
            d = max(d, sdBox(p, vec2(0.3 + sin(time + fi) * 0.1)));
          }

          return d;
        }

        // ボロノイ風パターン
        float voronoiPattern(vec2 uv, float time) {
          vec2 i = floor(uv * 5.0);
          vec2 f = fract(uv * 5.0);

          float minDist = 1.0;

          for (int y = -1; y <= 1; y++) {
            for (int x = -1; x <= 1; x++) {
              vec2 neighbor = vec2(float(x), float(y));
              vec2 point = 0.5 + 0.5 * sin(time + 6.2831 * (i + neighbor));
              float dist = length(neighbor + point - f);
              minDist = min(minDist, dist);
            }
          }

          return minDist;
        }

        // 波紋パターン
        float ripplePattern(vec2 uv, float time) {
          float d = length(uv);
          float wave = sin(d * 10.0 - time * 3.0) * 0.5 + 0.5;
          wave *= exp(-d * 2.0);
          return wave;
        }

        // メインシェーダー
        void main() {
          vec2 uv = vUv * 2.0 - 1.0;
          uv.x *= u_resolution.x / u_resolution.y;

          float t = u_time * 0.5;

          // 複数のパターンを組み合わせ
          uv *= rot(t * 0.1);

          float fractal = fractalPattern(uv, t);
          float voronoi = voronoiPattern(uv, t);
          float ripple = ripplePattern(uv, t);

          // フラクタルをベースに
          float pattern = smoothstep(0.1, 0.0, fractal);

          // ボロノイを追加
          pattern += voronoi * 0.3;

          // 波紋を追加
          pattern += ripple * 0.5;

          // 中心からの距離でビネット効果
          float vignette = 1.0 - length(uv * 0.5);
          vignette = smoothstep(0.0, 1.0, vignette);

          // カラーグラデーション
          vec3 col1 = vec3(0.1, 0.3, 0.8); // ブルー
          vec3 col2 = vec3(0.9, 0.2, 0.5); // ピンク
          vec3 col3 = vec3(0.3, 0.9, 0.6); // グリーン

          // 時間ベースのカラーミックス
          float colorMix1 = sin(t * 0.5) * 0.5 + 0.5;
          float colorMix2 = cos(t * 0.3) * 0.5 + 0.5;

          vec3 baseColor = mix(col1, col2, colorMix1);
          baseColor = mix(baseColor, col3, colorMix2);

          // パターンに基づいて色を調整
          vec3 color = baseColor * pattern;

          // グローエフェクト
          float glow = pattern * 0.5;
          color += vec3(glow) * 0.3;

          // ビネット適用
          color *= vignette;

          // 最終的な明るさ調整
          color = pow(color, vec3(0.8));

          gl_FragColor = vec4(color, 1.0);
        }
      `;

      const uniforms = {
        u_time: { value: 0.0 },
        u_resolution: {
          value: new THREE.Vector2(window.innerWidth, window.innerHeight),
        },
      };

      const material = new THREE.ShaderMaterial({
        uniforms: uniforms,
        vertexShader: vertexShader,
        fragmentShader: fragmentShader,
      });

      const geometry = new THREE.PlaneGeometry(2, 2);
      const mesh = new THREE.Mesh(geometry, material);
      scene.add(mesh);

      function animate() {
        requestAnimationFrame(animate);

        uniforms.u_time.value = performance.now() * 0.001;

        renderer.render(scene, camera);
      }
      animate();

      window.addEventListener("resize", () => {
        const width = window.innerWidth;
        const height = window.innerHeight;

        renderer.setSize(width, height);
        uniforms.u_resolution.value.set(width, height);
      });
    </script>
  </body>
</html>
