<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Fragment #126 â€“ Sparkling Jewel Box</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
      body {
        margin: 0;
        background: radial-gradient(circle, #1a0033 0%, #000000 100%);
        overflow: hidden;
        height: 100vh;
      }

      .caption {
        position: fixed;
        left: 20px;
        bottom: 20px;
        font-family: "Helvetica Neue", sans-serif;
        font-size: 0.9rem;
        color: rgba(255, 200, 255, 0.9);
        z-index: 10;
        text-shadow: 0 2px 8px rgba(255, 100, 255, 0.5);
      }
    </style>
  </head>

  <body>
    <div class="caption">Fragment #126 â€“ "Sparkling Jewel Box" ğŸ’</div>

    <script>
      const scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0x1a0033, 10, 30);

      const camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        100
      );
      camera.position.set(0, 3, 12);

      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);

      // ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
      scene.add(ambientLight);

      const light1 = new THREE.PointLight(0xff00ff, 2, 30);
      light1.position.set(5, 5, 5);
      scene.add(light1);

      const light2 = new THREE.PointLight(0x00ffff, 2, 30);
      light2.position.set(-5, 5, -5);
      scene.add(light2);

      const light3 = new THREE.PointLight(0xffff00, 1.5, 30);
      light3.position.set(0, -5, 5);
      scene.add(light3);

      // å®çŸ³ã®è‰²
      const gemColors = [
        0xff1493, // ãƒ”ãƒ³ã‚¯
        0x00bfff, // ã‚¹ã‚«ã‚¤ãƒ–ãƒ«ãƒ¼
        0x9370db, // ãƒ‘ãƒ¼ãƒ—ãƒ«
        0x00ff7f, // ã‚¨ãƒ¡ãƒ©ãƒ«ãƒ‰
        0xffd700, // ã‚´ãƒ¼ãƒ«ãƒ‰
        0xff69b4, // ãƒ›ãƒƒãƒˆãƒ”ãƒ³ã‚¯
        0x87ceeb, // ãƒ©ã‚¤ãƒˆãƒ–ãƒ«ãƒ¼
        0xda70d6, // ã‚ªãƒ¼ã‚­ãƒƒãƒ‰
      ];

      // ãƒ€ã‚¤ãƒ¤ãƒ¢ãƒ³ãƒ‰å‹ã®å®çŸ³ã‚’ä½œã‚‹
      function createGem(size, color) {
        const gemGroup = new THREE.Group();

        // ä¸Šéƒ¨ï¼ˆãƒ”ãƒ©ãƒŸãƒƒãƒ‰ï¼‰
        const topGeometry = new THREE.ConeGeometry(size, size * 1.2, 6);
        const gemMaterial = new THREE.MeshPhongMaterial({
          color: color,
          shininess: 150,
          transparent: true,
          opacity: 0.9,
          emissive: color,
          emissiveIntensity: 0.3,
        });
        const top = new THREE.Mesh(topGeometry, gemMaterial);
        top.position.y = size * 0.6;
        gemGroup.add(top);

        // ä¸‹éƒ¨ï¼ˆé€†ãƒ”ãƒ©ãƒŸãƒƒãƒ‰ï¼‰
        const bottomGeometry = new THREE.ConeGeometry(size, size * 0.8, 6);
        const bottom = new THREE.Mesh(bottomGeometry, gemMaterial);
        bottom.rotation.x = Math.PI;
        bottom.position.y = -size * 0.4;
        gemGroup.add(bottom);

        // ã‚°ãƒ­ãƒ¼åŠ¹æœ
        const glowGeometry = new THREE.SphereGeometry(size * 1.2, 16, 16);
        const glowMaterial = new THREE.MeshBasicMaterial({
          color: color,
          transparent: true,
          opacity: 0.2,
          blending: THREE.AdditiveBlending,
        });
        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
        gemGroup.add(glow);

        return gemGroup;
      }

      // å¤§ããªå®çŸ³ãŸã¡
      const largeGems = [];
      for (let i = 0; i < 8; i++) {
        const size = 0.5 + Math.random() * 0.5;
        const color = gemColors[i % gemColors.length];
        const gem = createGem(size, color);

        const angle = (i / 8) * Math.PI * 2;
        const radius = 6;
        gem.position.x = Math.cos(angle) * radius;
        gem.position.z = Math.sin(angle) * radius;
        gem.position.y = Math.sin(i * 0.5) * 2;

        gem.userData = {
          angle: angle,
          radius: radius,
          speed: 0.1 + Math.random() * 0.1,
          rotationSpeed: 0.01 + Math.random() * 0.01,
          bobSpeed: 0.5 + Math.random() * 0.5,
          bobAmount: 0.3 + Math.random() * 0.3,
        };

        scene.add(gem);
        largeGems.push(gem);
      }

      // å°ã•ãªå®çŸ³ãŸã¡
      const smallGems = [];
      for (let i = 0; i < 20; i++) {
        const size = 0.2 + Math.random() * 0.3;
        const color = gemColors[Math.floor(Math.random() * gemColors.length)];
        const gem = createGem(size, color);

        gem.position.x = (Math.random() - 0.5) * 15;
        gem.position.y = (Math.random() - 0.5) * 10;
        gem.position.z = (Math.random() - 0.5) * 15;

        gem.userData = {
          rotationSpeedX: (Math.random() - 0.5) * 0.02,
          rotationSpeedY: (Math.random() - 0.5) * 0.02,
          floatSpeed: 0.3 + Math.random() * 0.4,
          floatAmount: 0.2 + Math.random() * 0.3,
        };

        scene.add(gem);
        smallGems.push(gem);
      }

      // çµæ™¶
      const crystals = [];
      for (let i = 0; i < 12; i++) {
        const crystalGeometry = new THREE.OctahedronGeometry(0.4);
        const crystalMaterial = new THREE.MeshPhongMaterial({
          color: gemColors[Math.floor(Math.random() * gemColors.length)],
          shininess: 120,
          transparent: true,
          opacity: 0.8,
          wireframe: false,
        });

        const crystal = new THREE.Mesh(crystalGeometry, crystalMaterial);
        crystal.position.x = (Math.random() - 0.5) * 12;
        crystal.position.y = (Math.random() - 0.5) * 8;
        crystal.position.z = (Math.random() - 0.5) * 12;

        crystal.userData = {
          rotationSpeed: (Math.random() - 0.5) * 0.03,
          scale: 1,
        };

        scene.add(crystal);
        crystals.push(crystal);
      }

      // ã‚­ãƒ©ã‚­ãƒ©ãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«
      const sparklesGeometry = new THREE.BufferGeometry();
      const sparklesCount = 300;
      const sparklesPositions = new Float32Array(sparklesCount * 3);
      const sparklesColors = new Float32Array(sparklesCount * 3);
      const sparklesSizes = new Float32Array(sparklesCount);

      for (let i = 0; i < sparklesCount; i++) {
        const i3 = i * 3;

        sparklesPositions[i3] = (Math.random() - 0.5) * 30;
        sparklesPositions[i3 + 1] = (Math.random() - 0.5) * 20;
        sparklesPositions[i3 + 2] = (Math.random() - 0.5) * 30;

        const color = new THREE.Color(
          gemColors[Math.floor(Math.random() * gemColors.length)]
        );
        sparklesColors[i3] = color.r;
        sparklesColors[i3 + 1] = color.g;
        sparklesColors[i3 + 2] = color.b;

        sparklesSizes[i] = Math.random() * 0.3 + 0.1;
      }

      sparklesGeometry.setAttribute(
        "position",
        new THREE.BufferAttribute(sparklesPositions, 3)
      );
      sparklesGeometry.setAttribute(
        "color",
        new THREE.BufferAttribute(sparklesColors, 3)
      );
      sparklesGeometry.setAttribute(
        "size",
        new THREE.BufferAttribute(sparklesSizes, 1)
      );

      const sparklesMaterial = new THREE.PointsMaterial({
        vertexColors: true,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending,
        sizeAttenuation: true,
      });

      const sparkles = new THREE.Points(sparklesGeometry, sparklesMaterial);
      scene.add(sparkles);

      // å…‰ã®ãƒªãƒ³ã‚°
      const rings = [];
      for (let i = 0; i < 3; i++) {
        const ringGeometry = new THREE.TorusGeometry(3 + i * 1.5, 0.05, 16, 50);
        const ringMaterial = new THREE.MeshBasicMaterial({
          color: gemColors[i * 2],
          transparent: true,
          opacity: 0.4,
          blending: THREE.AdditiveBlending,
        });

        const ring = new THREE.Mesh(ringGeometry, ringMaterial);
        ring.rotation.x = Math.PI / 2;

        ring.userData = {
          rotationSpeed: 0.001 + i * 0.0005,
        };

        scene.add(ring);
        rings.push(ring);
      }

      // å®çŸ³ç®±ã®åœŸå°
      const platformGeometry = new THREE.CylinderGeometry(4, 4.5, 0.5, 32);
      const platformMaterial = new THREE.MeshPhongMaterial({
        color: 0x4b0082,
        shininess: 80,
        transparent: true,
        opacity: 0.6,
        emissive: 0x4b0082,
        emissiveIntensity: 0.2,
      });
      const platform = new THREE.Mesh(platformGeometry, platformMaterial);
      platform.position.y = -3;
      scene.add(platform);

      function animate() {
        requestAnimationFrame(animate);

        const t = performance.now() * 0.001;

        // å¤§ããªå®çŸ³ã®å›è»¢ã¨ç§»å‹•
        largeGems.forEach((gem) => {
          const data = gem.userData;
          data.angle += data.speed * 0.01;

          gem.position.x = Math.cos(data.angle) * data.radius;
          gem.position.z = Math.sin(data.angle) * data.radius;
          gem.position.y = Math.sin(t * data.bobSpeed) * data.bobAmount;

          gem.rotation.y += data.rotationSpeed;
        });

        // å°ã•ãªå®çŸ³ã®å›è»¢
        smallGems.forEach((gem) => {
          const data = gem.userData;
          gem.rotation.x += data.rotationSpeedX;
          gem.rotation.y += data.rotationSpeedY;
          gem.position.y += Math.sin(t * data.floatSpeed) * 0.01;
        });

        // çµæ™¶ã®å›è»¢ã¨è„ˆå‹•
        crystals.forEach((crystal) => {
          const data = crystal.userData;
          crystal.rotation.x += data.rotationSpeed;
          crystal.rotation.y += data.rotationSpeed * 1.5;

          const scale = 1 + Math.sin(t * 2) * 0.1;
          crystal.scale.set(scale, scale, scale);
        });

        // ã‚­ãƒ©ã‚­ãƒ©ã®ç‚¹æ»…
        const sizes = sparklesGeometry.attributes.size.array;
        for (let i = 0; i < sparklesCount; i++) {
          sizes[i] = (Math.sin(t * 3 + i) * 0.5 + 0.5) * 0.4 + 0.1;
        }
        sparklesGeometry.attributes.size.needsUpdate = true;
        sparkles.rotation.y = t * 0.1;

        // ãƒªãƒ³ã‚°ã®å›è»¢
        rings.forEach((ring) => {
          ring.rotation.z += ring.userData.rotationSpeed;
        });

        // åœŸå°ã®å›è»¢
        platform.rotation.y = t * 0.1;

        // ãƒ©ã‚¤ãƒˆã®å‹•ã
        light1.position.x = Math.cos(t) * 8;
        light1.position.z = Math.sin(t) * 8;

        light2.position.x = Math.cos(t + Math.PI * 0.66) * 8;
        light2.position.z = Math.sin(t + Math.PI * 0.66) * 8;

        light3.position.x = Math.cos(t + Math.PI * 1.33) * 8;
        light3.position.z = Math.sin(t + Math.PI * 1.33) * 8;

        // ã‚«ãƒ¡ãƒ©ã®å‹•ã
        camera.position.x = Math.sin(t * 0.2) * 2;
        camera.position.y = 3 + Math.cos(t * 0.15) * 1;
        camera.lookAt(0, 0, 0);

        renderer.render(scene, camera);
      }
      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
