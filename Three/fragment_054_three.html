<!-- fragment_054_three.html -->
!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Ancient Catacombs</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
      body {
        margin: 0;
        background: #000000;
        overflow: hidden;
        height: 100vh;
      }

      .caption {
        position: fixed;
        left: 20px;
        bottom: 20px;
        font-family: "Helvetica Neue", sans-serif;
        font-size: 0.9rem;
        color: rgba(150, 120, 80, 0.8);
        z-index: 10;
        text-shadow: 0 0 10px rgba(100, 70, 40, 0.5);
      }
    </style>
  </head>

  <body>
    <div class="caption">"Ancient Catacombs" ⚰️</div>

    <script>
      const scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x000000, 0.12);

      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        100
      );
      camera.position.set(0, 1.5, 5);

      const renderer = new THREE.WebGLRenderer({
        antialias: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);

      // 暗いライティング
      const ambientLight = new THREE.AmbientLight(0x1a1510, 0.1);
      scene.add(ambientLight);

      // 松明の炎
      const torchLights = [];
      for (let i = 0; i < 6; i++) {
        const torchLight = new THREE.PointLight(0xff6600, 0.8, 10);
        const z = -3 + i * -4;
        const x = i % 2 === 0 ? -3 : 3;
        torchLight.position.set(x, 2.5, z);
        scene.add(torchLight);
        torchLights.push(torchLight);

        // 松明の炎（視覚的）
        const flameGeometry = new THREE.ConeGeometry(0.15, 0.5, 6);
        const flameMaterial = new THREE.MeshBasicMaterial({
          color: 0xff6600,
          transparent: true,
          opacity: 0.8,
          blending: THREE.AdditiveBlending,
        });
        const flame = new THREE.Mesh(flameGeometry, flameMaterial);
        flame.position.copy(torchLight.position);
        scene.add(flame);

        torchLight.userData = { flame: flame };
      }

      // 地下墓地の壁
      const catacombs = new THREE.Group();

      // 石の壁のテクスチャ風マテリアル
      const stoneMaterial = new THREE.MeshPhongMaterial({
        color: 0x3a3020,
        shininess: 2,
      });

      // 左右の壁
      const wallGeometry = new THREE.BoxGeometry(0.5, 4, 30);
      const leftWall = new THREE.Mesh(wallGeometry, stoneMaterial);
      leftWall.position.set(-4, 2, 0);
      catacombs.add(leftWall);

      const rightWall = new THREE.Mesh(wallGeometry, stoneMaterial);
      rightWall.position.set(4, 2, 0);
      catacombs.add(rightWall);

      // 天井（アーチ型風）
      const ceilingGeometry = new THREE.CylinderGeometry(
        4,
        4,
        30,
        16,
        1,
        false,
        0,
        Math.PI
      );
      const ceiling = new THREE.Mesh(ceilingGeometry, stoneMaterial);
      ceiling.rotation.z = Math.PI / 2;
      ceiling.rotation.y = Math.PI / 2;
      ceiling.position.y = 4;
      catacombs.add(ceiling);

      scene.add(catacombs);

      // 床
      const floorGeometry = new THREE.PlaneGeometry(8, 30);
      const floorMaterial = new THREE.MeshPhongMaterial({
        color: 0x2a2010,
        shininess: 0,
      });
      const floor = new THREE.Mesh(floorGeometry, floorMaterial);
      floor.rotation.x = -Math.PI / 2;
      scene.add(floor);

      // 壁龕（遺体を収める場所）
      const niches = [];
      for (let i = 0; i < 10; i++) {
        const niche = new THREE.Group();

        // 窪み
        const nicheGeometry = new THREE.BoxGeometry(1.5, 0.8, 0.8);
        const nicheMaterial = new THREE.MeshPhongMaterial({
          color: 0x1a1510,
          shininess: 0,
        });
        const nicheBox = new THREE.Mesh(nicheGeometry, nicheMaterial);
        niche.add(nicheBox);

        // 骨
        for (let j = 0; j < 3; j++) {
          const boneGeometry = new THREE.CylinderGeometry(0.05, 0.05, 0.6, 8);
          const boneMaterial = new THREE.MeshPhongMaterial({
            color: 0xccccaa,
          });
          const bone = new THREE.Mesh(boneGeometry, boneMaterial);
          bone.position.set((j - 1) * 0.3, 0, 0.2);
          bone.rotation.z = (Math.random() - 0.5) * 0.5;
          niche.add(bone);

          // 頭蓋骨
          if (j === 1) {
            const skullGeometry = new THREE.SphereGeometry(0.2, 16, 16);
            const skull = new THREE.Mesh(skullGeometry, boneMaterial);
            skull.position.set(0, 0.2, 0.2);
            niche.add(skull);

            // 目の穴
            const eyeHoleGeometry = new THREE.SphereGeometry(0.05, 8, 8);
            const eyeHoleMaterial = new THREE.MeshBasicMaterial({
              color: 0x000000,
            });

            const leftEye = new THREE.Mesh(eyeHoleGeometry, eyeHoleMaterial);
            leftEye.position.set(-0.08, 0.23, 0.35);
            niche.add(leftEye);

            const rightEye = new THREE.Mesh(eyeHoleGeometry, eyeHoleMaterial);
            rightEye.position.set(0.08, 0.23, 0.35);
            niche.add(rightEye);

            // 不気味な赤い光
            const eyeGlowGeometry = new THREE.SphereGeometry(0.03, 8, 8);
            const eyeGlowMaterial = new THREE.MeshBasicMaterial({
              color: 0xff0000,
              transparent: true,
              opacity: 0.8,
              blending: THREE.AdditiveBlending,
            });

            const leftGlow = new THREE.Mesh(eyeGlowGeometry, eyeGlowMaterial);
            leftGlow.position.set(-0.08, 0.23, 0.38);
            niche.add(leftGlow);

            const rightGlow = new THREE.Mesh(eyeGlowGeometry, eyeGlowMaterial);
            rightGlow.position.set(0.08, 0.23, 0.38);
            niche.add(rightGlow);
          }
        }

        const side = i % 2 === 0 ? -3.6 : 3.6;
        niche.position.set(side, 1.5 + (i % 3) * 0.9, -2 - i * 2.5);
        niche.rotation.y = side < 0 ? Math.PI / 2 : -Math.PI / 2;

        scene.add(niche);
        niches.push(niche);
      }

      // 棺桶
      const coffins = [];
      for (let i = 0; i < 3; i++) {
        const coffin = new THREE.Group();

        // 棺桶の本体
        const coffinGeometry = new THREE.BoxGeometry(1.2, 0.6, 2.2);
        const coffinMaterial = new THREE.MeshPhongMaterial({
          color: 0x2a1510,
          shininess: 10,
        });
        const coffinBox = new THREE.Mesh(coffinGeometry, coffinMaterial);
        coffinBox.position.y = 0.3;
        coffin.add(coffinBox);

        // 蓋（半開き）
        const lidGeometry = new THREE.BoxGeometry(1.3, 0.15, 2.3);
        const lid = new THREE.Mesh(lidGeometry, coffinMaterial);
        lid.position.set(-0.4, 0.7, 0.5);
        lid.rotation.z = -0.5;
        coffin.add(lid);

        coffin.position.set((i - 1) * 2, 0, -5 - i * 4);
        coffin.rotation.y = (Math.random() - 0.5) * 0.3;

        scene.add(coffin);
        coffins.push(coffin);
      }

      // 浮遊する骸骨の手
      const skeletonHands = [];
      for (let i = 0; i < 6; i++) {
        const hand = new THREE.Group();

        // 手のひら
        const palmGeometry = new THREE.BoxGeometry(0.3, 0.4, 0.1);
        const boneMaterial = new THREE.MeshPhongMaterial({
          color: 0xccccaa,
        });
        const palm = new THREE.Mesh(palmGeometry, boneMaterial);
        hand.add(palm);

        // 指
        for (let f = 0; f < 5; f++) {
          const fingerGeometry = new THREE.CylinderGeometry(0.02, 0.02, 0.3, 6);
          const finger = new THREE.Mesh(fingerGeometry, boneMaterial);
          finger.position.set((f - 2) * 0.07, 0.35, 0);
          finger.rotation.z = (f - 2) * 0.15;
          hand.add(finger);
        }

        hand.position.set(
          (Math.random() - 0.5) * 6,
          1 + Math.random() * 2,
          (Math.random() - 0.5) * 20
        );

        hand.userData = {
          floatSpeed: 0.3 + Math.random() * 0.4,
          floatAmount: 0.2 + Math.random() * 0.2,
          rotationSpeed: 0.01 + Math.random() * 0.01,
          reachSpeed: 1 + Math.random(),
        };

        scene.add(hand);
        skeletonHands.push(hand);
      }

      // 蜘蛛
      const spiders = [];
      for (let i = 0; i < 8; i++) {
        const spider = new THREE.Group();

        // 体
        const bodyGeometry = new THREE.SphereGeometry(0.1, 8, 8);
        const spiderMaterial = new THREE.MeshPhongMaterial({
          color: 0x1a1a1a,
          shininess: 50,
        });
        const body = new THREE.Mesh(bodyGeometry, spiderMaterial);
        spider.add(body);

        // 脚
        for (let l = 0; l < 8; l++) {
          const legGeometry = new THREE.CylinderGeometry(0.01, 0.01, 0.3, 4);
          const leg = new THREE.Mesh(legGeometry, spiderMaterial);

          const angle = (l / 8) * Math.PI * 2;
          leg.position.set(Math.cos(angle) * 0.15, 0, Math.sin(angle) * 0.15);
          leg.rotation.x = Math.PI / 3;
          leg.rotation.y = angle;

          spider.add(leg);
        }

        spider.position.set(
          (Math.random() - 0.5) * 7,
          Math.random() * 3 + 0.5,
          (Math.random() - 0.5) * 25
        );

        spider.userData = {
          moveSpeed: 0.005 + Math.random() * 0.01,
          direction: new THREE.Vector3(
            (Math.random() - 0.5) * 0.1,
            (Math.random() - 0.5) * 0.05,
            (Math.random() - 0.5) * 0.1
          ),
        };

        scene.add(spider);
        spiders.push(spider);
      }

      // ろうそく
      const candles = [];
      for (let i = 0; i < 5; i++) {
        const candle = new THREE.Group();

        const candleGeometry = new THREE.CylinderGeometry(0.08, 0.1, 0.5, 8);
        const candleMaterial = new THREE.MeshPhongMaterial({
          color: 0xccccaa,
        });
        const candleBody = new THREE.Mesh(candleGeometry, candleMaterial);
        candle.add(candleBody);

        // 炎
        const flameGeometry = new THREE.SphereGeometry(0.1, 8, 8);
        flameGeometry.scale(1, 1.5, 1);
        const flameMaterial = new THREE.MeshBasicMaterial({
          color: 0xff8800,
          transparent: true,
          opacity: 0.8,
          blending: THREE.AdditiveBlending,
        });
        const flame = new THREE.Mesh(flameGeometry, flameMaterial);
        flame.position.y = 0.35;
        candle.add(flame);

        // 光源
        const candleLight = new THREE.PointLight(0xff8800, 0.5, 5);
        candleLight.position.y = 0.35;
        candle.add(candleLight);

        candle.position.set((Math.random() - 0.5) * 6, 0.25, -5 - i * 4);

        candle.userData = { flame: flame, light: candleLight };

        scene.add(candle);
        candles.push(candle);
      }

      function animate() {
        requestAnimationFrame(animate);

        const t = performance.now() * 0.001;

        // 松明の炎の揺らぎ
        torchLights.forEach((light, index) => {
          light.intensity = 0.6 + Math.sin(t * 3 + index) * 0.2;
          const flame = light.userData.flame;
          flame.scale.y = 1 + Math.sin(t * 5 + index) * 0.2;
        });

        // 骸骨の手の動き
        skeletonHands.forEach((hand) => {
          const data = hand.userData;
          hand.position.y += Math.sin(t * data.floatSpeed) * 0.01;
          hand.rotation.y += data.rotationSpeed;

          // カメラに向かって伸びる
          const reach = Math.sin(t * data.reachSpeed);
          hand.scale.set(1 + reach * 0.2, 1 + reach * 0.2, 1 + reach * 0.2);
        });

        // 蜘蛛の動き
        spiders.forEach((spider) => {
          const data = spider.userData;
          spider.position.add(data.direction);

          // 壁にぶつかったら方向転換
          if (Math.abs(spider.position.x) > 3.5) {
            data.direction.x *= -1;
          }
          if (spider.position.y < 0.2 || spider.position.y > 3.5) {
            data.direction.y *= -1;
          }
        });

        // ろうそくの炎の揺らぎ
        candles.forEach((candle, index) => {
          const flame = candle.userData.flame;
          const light = candle.userData.light;

          flame.scale.y = 1 + Math.sin(t * 4 + index) * 0.3;
          light.intensity = 0.4 + Math.sin(t * 4 + index) * 0.1;
        });

        // カメラの不気味な動き
        camera.position.x = Math.sin(t * 0.2) * 0.3;
        camera.position.y = 1.5 + Math.sin(t * 0.25) * 0.15;
        camera.lookAt(0, 1.5, -10);

        renderer.render(scene, camera);
      }
      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
