<!-- fragment_042_three.html -->
<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Fragment #143 – Psychedelic Waves</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
      body {
        margin: 0;
        background: #000000;
        overflow: hidden;
        height: 100vh;
      }

      .caption {
        position: fixed;
        left: 20px;
        bottom: 20px;
        font-family: "Helvetica Neue", sans-serif;
        font-size: 0.9rem;
        color: rgba(255, 255, 255, 0.9);
        z-index: 10;
        text-shadow: 0 2px 8px rgba(255, 0, 128, 0.8);
      }
    </style>
  </head>

  <body>
    <div class="caption">Fragment #143 – "Psychedelic Waves" 〰️</div>

    <script>
      const scene = new THREE.Scene();

      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        200
      );
      camera.position.set(0, 20, 40);
      camera.lookAt(0, 0, 0);

      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);

      // 波面を作成
      function createWavePlane(width, height, segmentsX, segmentsY, color) {
        const geometry = new THREE.PlaneGeometry(
          width,
          height,
          segmentsX,
          segmentsY
        );

        const material = new THREE.ShaderMaterial({
          uniforms: {
            time: { value: 0 },
            baseColor: { value: new THREE.Color(color) },
          },
          vertexShader: `
            uniform float time;
            varying vec2 vUv;
            varying float vHeight;

            void main() {
              vUv = uv;
              vec3 pos = position;

              float wave1 = sin(pos.x * 0.3 + time * 2.0) * 3.0;
              float wave2 = sin(pos.y * 0.2 + time * 1.5) * 2.0;
              float wave3 = sin(pos.x * 0.5 + pos.y * 0.3 + time * 3.0) * 1.5;
              float wave4 = cos(pos.x * 0.1 - pos.y * 0.4 + time * 2.5) * 2.5;

              pos.z = wave1 + wave2 + wave3 + wave4;
              vHeight = pos.z;

              gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
          `,
          fragmentShader: `
            uniform float time;
            uniform vec3 baseColor;
            varying vec2 vUv;
            varying float vHeight;

            void main() {
              float hue = fract(vHeight * 0.1 + time * 0.1);
              vec3 color1 = vec3(
                0.5 + 0.5 * sin(hue * 6.28318 + 0.0),
                0.5 + 0.5 * sin(hue * 6.28318 + 2.09439),
                0.5 + 0.5 * sin(hue * 6.28318 + 4.18879)
              );

              float stripe = sin(vUv.x * 20.0 + time * 5.0) * 0.5 + 0.5;
              stripe *= sin(vUv.y * 20.0 - time * 3.0) * 0.5 + 0.5;

              vec3 finalColor = mix(color1, baseColor, stripe * 0.3);

              gl_FragColor = vec4(finalColor, 0.9);
            }
          `,
          transparent: true,
          side: THREE.DoubleSide,
          blending: THREE.AdditiveBlending,
        });

        return new THREE.Mesh(geometry, material);
      }

      // 複数の波面レイヤー
      const wavePlanes = [];
      const colors = [
        0xff0080, 0x00ff80, 0x8000ff, 0xff8000, 0x0080ff, 0x80ff00,
      ];

      for (let i = 0; i < 6; i++) {
        const wave = createWavePlane(80, 80, 100, 100, colors[i]);
        wave.position.y = i * 3 - 7.5;
        wave.rotation.x = -Math.PI / 3;

        wave.userData = {
          timeOffset: (i * Math.PI) / 3,
          rotateSpeed: 0.1 + i * 0.05,
        };

        scene.add(wave);
        wavePlanes.push(wave);
      }

      // 浮遊する球体
      const spheres = [];
      for (let i = 0; i < 30; i++) {
        const sphereGeometry = new THREE.SphereGeometry(
          0.5 + Math.random() * 1,
          16,
          16
        );
        const hue = Math.random();
        const color = new THREE.Color().setHSL(hue, 1, 0.5);
        const sphereMaterial = new THREE.MeshBasicMaterial({
          color: color,
          transparent: true,
          opacity: 0.7,
          blending: THREE.AdditiveBlending,
        });
        const sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);

        sphere.position.x = (Math.random() - 0.5) * 60;
        sphere.position.y = Math.random() * 30 - 10;
        sphere.position.z = (Math.random() - 0.5) * 60;

        sphere.userData = {
          hue: hue,
          floatSpeed: 0.5 + Math.random() * 1,
          floatAmount: 2 + Math.random() * 3,
          floatOffset: Math.random() * Math.PI * 2,
          rotateSpeed: (Math.random() - 0.5) * 0.05,
          pulseSpeed: 1 + Math.random() * 2,
        };

        scene.add(sphere);
        spheres.push(sphere);
      }

      // 光の軌跡
      const trailLines = [];
      for (let i = 0; i < 20; i++) {
        const points = [];
        const segmentCount = 50;

        for (let j = 0; j < segmentCount; j++) {
          const angle = (j / segmentCount) * Math.PI * 4;
          const radius = 10 + j * 0.5;
          const x = Math.cos(angle) * radius;
          const y = j * 0.5 - 10;
          const z = Math.sin(angle) * radius;
          points.push(new THREE.Vector3(x, y, z));
        }

        const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
        const hue = i / 20;
        const color = new THREE.Color().setHSL(hue, 1, 0.5);
        const lineMaterial = new THREE.LineBasicMaterial({
          color: color,
          transparent: true,
          opacity: 0.6,
          blending: THREE.AdditiveBlending,
        });
        const line = new THREE.Line(lineGeometry, lineMaterial);

        line.rotation.y = (i / 20) * Math.PI * 2;

        line.userData = {
          hue: hue,
          rotateSpeed: 0.5 + Math.random() * 0.5,
        };

        scene.add(line);
        trailLines.push(line);
      }

      // 粒子
      const particleGeometry = new THREE.BufferGeometry();
      const particleCount = 1000;
      const particlePositions = new Float32Array(particleCount * 3);
      const particleColors = new Float32Array(particleCount * 3);

      for (let i = 0; i < particleCount; i++) {
        const i3 = i * 3;

        particlePositions[i3] = (Math.random() - 0.5) * 100;
        particlePositions[i3 + 1] = (Math.random() - 0.5) * 50;
        particlePositions[i3 + 2] = (Math.random() - 0.5) * 100;

        const hue = Math.random();
        const color = new THREE.Color().setHSL(hue, 1, 0.5);
        particleColors[i3] = color.r;
        particleColors[i3 + 1] = color.g;
        particleColors[i3 + 2] = color.b;
      }

      particleGeometry.setAttribute(
        "position",
        new THREE.BufferAttribute(particlePositions, 3)
      );
      particleGeometry.setAttribute(
        "color",
        new THREE.BufferAttribute(particleColors, 3)
      );

      const particleMaterial = new THREE.PointsMaterial({
        size: 0.3,
        vertexColors: true,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending,
      });

      const particles = new THREE.Points(particleGeometry, particleMaterial);
      scene.add(particles);

      // ライト
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.2);
      scene.add(ambientLight);

      const lights = [];
      for (let i = 0; i < 5; i++) {
        const hue = i / 5;
        const color = new THREE.Color().setHSL(hue, 1, 0.5);
        const light = new THREE.PointLight(color, 2, 50);
        scene.add(light);
        lights.push(light);
      }

      function animate() {
        requestAnimationFrame(animate);

        const t = performance.now() * 0.001;

        // 波面の更新
        wavePlanes.forEach((wave, index) => {
          const data = wave.userData;
          wave.material.uniforms.time.value = t + data.timeOffset;
          wave.rotation.z = Math.sin(t * data.rotateSpeed) * 0.2;
        });

        // 球体の動き
        spheres.forEach((sphere, index) => {
          const data = sphere.userData;

          const float =
            Math.sin(t * data.floatSpeed + data.floatOffset) * data.floatAmount;
          sphere.position.y += float * 0.01;

          sphere.rotation.x += data.rotateSpeed;
          sphere.rotation.y += data.rotateSpeed * 1.5;

          const pulse = Math.sin(t * data.pulseSpeed + index) * 0.5 + 0.5;
          sphere.scale.setScalar(1 + pulse * 0.3);

          const hue = (data.hue + t * 0.1) % 1;
          const color = new THREE.Color().setHSL(hue, 1, 0.5);
          sphere.material.color.copy(color);
          sphere.material.opacity = 0.5 + pulse * 0.3;
        });

        // 光の軌跡の回転
        trailLines.forEach((line) => {
          const data = line.userData;
          line.rotation.y += data.rotateSpeed * 0.01;
          line.rotation.x = Math.sin(t * 0.3) * 0.3;

          const hue = (data.hue + t * 0.1) % 1;
          const color = new THREE.Color().setHSL(hue, 1, 0.5);
          line.material.color.copy(color);
        });

        // 粒子の動き
        const particlePos = particleGeometry.attributes.position.array;
        const particleCol = particleGeometry.attributes.color.array;

        for (let i = 0; i < particleCount; i++) {
          const i3 = i * 3;

          particlePos[i3] += Math.sin(t + i * 0.1) * 0.05;
          particlePos[i3 + 1] += Math.cos(t * 0.7 + i * 0.2) * 0.05;
          particlePos[i3 + 2] += Math.sin(t * 0.5 + i * 0.15) * 0.05;

          const hue = (t * 0.1 + i * 0.01) % 1;
          const color = new THREE.Color().setHSL(hue, 1, 0.5);
          particleCol[i3] = color.r;
          particleCol[i3 + 1] = color.g;
          particleCol[i3 + 2] = color.b;
        }
        particleGeometry.attributes.position.needsUpdate = true;
        particleGeometry.attributes.color.needsUpdate = true;

        // ライトの動き
        lights.forEach((light, index) => {
          const angle = t * 0.5 + (index / lights.length) * Math.PI * 2;
          light.position.x = Math.cos(angle) * 30;
          light.position.y = 10 + Math.sin(t + index) * 10;
          light.position.z = Math.sin(angle) * 30;

          const hue = (t * 0.1 + index / lights.length) % 1;
          light.color.setHSL(hue, 1, 0.5);
        });

        // カメラの動き
        camera.position.x = Math.sin(t * 0.1) * 50;
        camera.position.z = 40 + Math.cos(t * 0.1) * 20;
        camera.position.y = 20 + Math.sin(t * 0.15) * 10;
        camera.lookAt(0, 0, 0);

        renderer.render(scene, camera);
      }
      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
