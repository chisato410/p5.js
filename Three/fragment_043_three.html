<!-- fragment_043_three.html -->
<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Fragment #144 â€“ Rainbow Vortex</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
      body {
        margin: 0;
        background: #000000;
        overflow: hidden;
        height: 100vh;
      }

      .caption {
        position: fixed;
        left: 20px;
        bottom: 20px;
        font-family: "Helvetica Neue", sans-serif;
        font-size: 0.9rem;
        color: rgba(255, 255, 255, 0.9);
        z-index: 10;
        text-shadow: 0 2px 8px rgba(255, 128, 0, 0.8);
      }
    </style>
  </head>

  <body>
    <div class="caption">Fragment #144 â€“ "Rainbow Vortex" ğŸŒˆ</div>

    <script>
      const scene = new THREE.Scene();

      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        300
      );
      camera.position.set(0, 0, 50);

      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);

      // æ¸¦ã®èºæ—‹ã‚’ä½œæˆ
      function createVortexSpiral(
        turns,
        segments,
        startRadius,
        endRadius,
        height
      ) {
        const points = [];

        for (let i = 0; i <= segments; i++) {
          const t = i / segments;
          const angle = t * Math.PI * 2 * turns;
          const radius = startRadius + (endRadius - startRadius) * t;
          const y = (t - 0.5) * height;

          const x = Math.cos(angle) * radius;
          const z = Math.sin(angle) * radius;

          points.push(new THREE.Vector3(x, y, z));
        }

        return points;
      }

      // è™¹è‰²ã®æ¸¦ã‚’è¤‡æ•°ä½œæˆ
      const vortexSpirals = [];
      const spiralCount = 12;

      for (let layer = 0; layer < spiralCount; layer++) {
        const turns = 8 + layer * 2;
        const segments = 200;
        const startRadius = 0.5 + layer * 0.5;
        const endRadius = 30 + layer * 3;
        const height = 100 + layer * 10;

        const points = createVortexSpiral(
          turns,
          segments,
          startRadius,
          endRadius,
          height
        );
        const geometry = new THREE.BufferGeometry().setFromPoints(points);

        // å„ç‚¹ã«è‰²ã‚’å‰²ã‚Šå½“ã¦
        const colors = new Float32Array(points.length * 3);
        for (let i = 0; i < points.length; i++) {
          const hue = (i / points.length + layer / spiralCount) % 1;
          const color = new THREE.Color().setHSL(hue, 1, 0.5);
          colors[i * 3] = color.r;
          colors[i * 3 + 1] = color.g;
          colors[i * 3 + 2] = color.b;
        }
        geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));

        const material = new THREE.LineBasicMaterial({
          vertexColors: true,
          transparent: true,
          opacity: 0.8,
          blending: THREE.AdditiveBlending,
          linewidth: 2,
        });

        const spiral = new THREE.Line(geometry, material);
        spiral.userData = {
          rotateSpeed: 0.5 + layer * 0.1,
          layer: layer,
        };

        scene.add(spiral);
        vortexSpirals.push(spiral);
      }

      // æ¸¦ã®ä¸­å¿ƒã®ã‚³ã‚¢
      const coreGeometry = new THREE.SphereGeometry(2, 32, 32);
      const coreMaterial = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        transparent: true,
        opacity: 0.9,
        blending: THREE.AdditiveBlending,
      });
      const core = new THREE.Mesh(coreGeometry, coreMaterial);
      scene.add(core);

      // ã‚³ã‚¢ã®ã‚°ãƒ­ãƒ¼å±¤
      const glowLayers = [];
      for (let i = 0; i < 5; i++) {
        const glowGeometry = new THREE.SphereGeometry(3 + i * 1.5, 32, 32);
        const glowMaterial = new THREE.MeshBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0.2 - i * 0.03,
          blending: THREE.AdditiveBlending,
        });
        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
        scene.add(glow);
        glowLayers.push(glow);
      }

      // æ¸¦ã‹ã‚‰é£›ã³å‡ºã™ç²’å­
      const particleGeometry = new THREE.BufferGeometry();
      const particleCount = 2000;
      const particlePositions = new Float32Array(particleCount * 3);
      const particleColors = new Float32Array(particleCount * 3);
      const particleVelocities = [];

      for (let i = 0; i < particleCount; i++) {
        const i3 = i * 3;

        const angle = Math.random() * Math.PI * 2;
        const radius = Math.random() * 5;
        particlePositions[i3] = Math.cos(angle) * radius;
        particlePositions[i3 + 1] = (Math.random() - 0.5) * 10;
        particlePositions[i3 + 2] = Math.sin(angle) * radius;

        const hue = Math.random();
        const color = new THREE.Color().setHSL(hue, 1, 0.5);
        particleColors[i3] = color.r;
        particleColors[i3 + 1] = color.g;
        particleColors[i3 + 2] = color.b;

        const speed = 0.1 + Math.random() * 0.3;
        particleVelocities.push({
          angle: angle,
          speed: speed,
          verticalSpeed: (Math.random() - 0.5) * 0.1,
        });
      }

      particleGeometry.setAttribute(
        "position",
        new THREE.BufferAttribute(particlePositions, 3)
      );
      particleGeometry.setAttribute(
        "color",
        new THREE.BufferAttribute(particleColors, 3)
      );

      const particleMaterial = new THREE.PointsMaterial({
        size: 0.4,
        vertexColors: true,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending,
      });

      const particles = new THREE.Points(particleGeometry, particleMaterial);
      scene.add(particles);

      // ã‚¨ãƒãƒ«ã‚®ãƒ¼ãƒªãƒ³ã‚°
      const energyRings = [];
      for (let i = 0; i < 10; i++) {
        const ringGeometry = new THREE.TorusGeometry(5 + i * 5, 0.3, 16, 64);
        const hue = i / 10;
        const color = new THREE.Color().setHSL(hue, 1, 0.5);
        const ringMaterial = new THREE.MeshBasicMaterial({
          color: color,
          transparent: true,
          opacity: 0.6,
          blending: THREE.AdditiveBlending,
        });
        const ring = new THREE.Mesh(ringGeometry, ringMaterial);
        ring.rotation.x = Math.PI / 2;
        ring.position.y = (Math.random() - 0.5) * 80;

        ring.userData = {
          hue: hue,
          initialY: ring.position.y,
          speed: 0.5 + Math.random() * 1,
          rotateSpeed: 0.5 + Math.random() * 1,
        };

        scene.add(ring);
        energyRings.push(ring);
      }

      // è™¹è‰²ã®å…‰ç·š
      const lightRays = [];
      const rayCount = 20;

      for (let i = 0; i < rayCount; i++) {
        const angle = (i / rayCount) * Math.PI * 2;
        const rayPoints = [];

        for (let j = 0; j < 50; j++) {
          const t = j / 50;
          const distance = t * 80;
          const x = Math.cos(angle) * distance;
          const y = (Math.random() - 0.5) * 5;
          const z = Math.sin(angle) * distance;
          rayPoints.push(new THREE.Vector3(x, y, z));
        }

        const rayGeometry = new THREE.BufferGeometry().setFromPoints(rayPoints);
        const hue = i / rayCount;
        const color = new THREE.Color().setHSL(hue, 1, 0.5);
        const rayMaterial = new THREE.LineBasicMaterial({
          color: color,
          transparent: true,
          opacity: 0.4,
          blending: THREE.AdditiveBlending,
        });
        const ray = new THREE.Line(rayGeometry, rayMaterial);

        ray.userData = {
          hue: hue,
          pulseSpeed: 1 + Math.random() * 2,
        };

        scene.add(ray);
        lightRays.push(ray);
      }

      function animate() {
        requestAnimationFrame(animate);

        const t = performance.now() * 0.001;

        // æ¸¦ã®å›è»¢ã¨è‰²ã®å¤‰åŒ–
        vortexSpirals.forEach((spiral) => {
          const data = spiral.userData;
          spiral.rotation.y = t * data.rotateSpeed;
          spiral.rotation.z = Math.sin(t * 0.5) * 0.2;

          // è‰²ã®æ›´æ–°
          const colors = spiral.geometry.attributes.color.array;
          const pointCount = colors.length / 3;

          for (let i = 0; i < pointCount; i++) {
            const hue = (i / pointCount + data.layer / 12 + t * 0.1) % 1;
            const color = new THREE.Color().setHSL(hue, 1, 0.5);
            colors[i * 3] = color.r;
            colors[i * 3 + 1] = color.g;
            colors[i * 3 + 2] = color.b;
          }
          spiral.geometry.attributes.color.needsUpdate = true;
        });

        // ã‚³ã‚¢ã®è„ˆå‹•
        const corePulse = Math.sin(t * 2) * 0.5 + 0.5;
        core.scale.setScalar(1 + corePulse * 0.5);

        const coreHue = (t * 0.2) % 1;
        core.material.color.setHSL(coreHue, 1, 0.8);

        // ã‚°ãƒ­ãƒ¼å±¤
        glowLayers.forEach((glow, index) => {
          const pulse = Math.sin(t * 2 + index * 0.3) * 0.5 + 0.5;
          glow.scale.setScalar(1 + corePulse * 0.3 + pulse * 0.2);

          const hue = (coreHue + index * 0.1) % 1;
          glow.material.color.setHSL(hue, 1, 0.7);
          glow.material.opacity = 0.15 - index * 0.02 + pulse * 0.05;
        });

        // ç²’å­ã®èºæ—‹é‹å‹•
        const particlePos = particleGeometry.attributes.position.array;
        const particleCol = particleGeometry.attributes.color.array;

        for (let i = 0; i < particleCount; i++) {
          const i3 = i * 3;
          const vel = particleVelocities[i];

          const currentX = particlePos[i3];
          const currentZ = particlePos[i3 + 2];
          const currentRadius = Math.sqrt(
            currentX * currentX + currentZ * currentZ
          );

          vel.angle += vel.speed * 0.02;
          const newRadius = currentRadius + vel.speed;

          particlePos[i3] = Math.cos(vel.angle) * newRadius;
          particlePos[i3 + 1] += vel.verticalSpeed;
          particlePos[i3 + 2] = Math.sin(vel.angle) * newRadius;

          // ãƒªã‚»ãƒƒãƒˆ
          if (newRadius > 100 || Math.abs(particlePos[i3 + 1]) > 60) {
            const angle = Math.random() * Math.PI * 2;
            const radius = Math.random() * 5;
            particlePos[i3] = Math.cos(angle) * radius;
            particlePos[i3 + 1] = (Math.random() - 0.5) * 10;
            particlePos[i3 + 2] = Math.sin(angle) * radius;

            vel.angle = angle;
            vel.speed = 0.1 + Math.random() * 0.3;
            vel.verticalSpeed = (Math.random() - 0.5) * 0.1;
          }

          // è‰²ã®å¤‰åŒ–
          const hue = (t * 0.2 + i * 0.005) % 1;
          const color = new THREE.Color().setHSL(hue, 1, 0.5);
          particleCol[i3] = color.r;
          particleCol[i3 + 1] = color.g;
          particleCol[i3 + 2] = color.b;
        }
        particleGeometry.attributes.position.needsUpdate = true;
        particleGeometry.attributes.color.needsUpdate = true;

        // ã‚¨ãƒãƒ«ã‚®ãƒ¼ãƒªãƒ³ã‚°
        energyRings.forEach((ring) => {
          const data = ring.userData;

          ring.rotation.z += data.rotateSpeed * 0.02;
          ring.position.y = data.initialY + Math.sin(t * data.speed) * 20;

          const scale = 1 + Math.sin(t * data.speed * 1.5) * 0.2;
          ring.scale.setScalar(scale);

          const hue = (data.hue + t * 0.1) % 1;
          ring.material.color.setHSL(hue, 1, 0.5);
          ring.material.opacity = 0.4 + Math.sin(t * 2 + data.hue * 10) * 0.3;
        });

        // å…‰ç·šã®è„ˆå‹•
        lightRays.forEach((ray) => {
          const data = ray.userData;
          const pulse = Math.sin(t * data.pulseSpeed) * 0.5 + 0.5;

          ray.material.opacity = 0.2 + pulse * 0.4;

          const hue = (data.hue + t * 0.1) % 1;
          ray.material.color.setHSL(hue, 1, 0.5);

          ray.rotation.y = t * 0.3;
        });

        // ã‚«ãƒ¡ãƒ©ã®å‹•ã
        camera.position.x = Math.sin(t * 0.1) * 60;
        camera.position.y = Math.cos(t * 0.15) * 40;
        camera.position.z = 50 + Math.sin(t * 0.08) * 20;
        camera.lookAt(0, 0, 0);

        renderer.render(scene, camera);
      }
      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
