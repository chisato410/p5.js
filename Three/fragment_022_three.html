<!-- fragment_022_three.html -->
<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Fragment #123 ‚Äì Pastel Candy Land</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
      body {
        margin: 0;
        background: linear-gradient(
          135deg,
          #fff5e6 0%,
          #ffe6f0 50%,
          #e6f0ff 100%
        );
        overflow: hidden;
        height: 100vh;
      }

      .caption {
        position: fixed;
        left: 20px;
        bottom: 20px;
        font-family: "Helvetica Neue", sans-serif;
        font-size: 0.9rem;
        color: rgba(255, 150, 200, 0.9);
        z-index: 10;
        text-shadow: 0 2px 4px rgba(255, 255, 255, 0.5);
      }
    </style>
  </head>

  <body>
    <div class="caption">Fragment #123 ‚Äì "Pastel Candy Land" üç¨</div>

    <script>
      const scene = new THREE.Scene();

      const camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        100
      );
      camera.position.set(0, 3, 12);

      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);

      // „É©„Ç§„ÉÜ„Ç£„É≥„Ç∞
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.7);
      scene.add(ambientLight);

      const light1 = new THREE.DirectionalLight(0xffd0e0, 0.8);
      light1.position.set(5, 5, 5);
      scene.add(light1);

      const light2 = new THREE.PointLight(0xe0d0ff, 0.6, 50);
      light2.position.set(-5, 3, -5);
      scene.add(light2);

      // „Ç≠„É£„É≥„Éá„Ç£„ÅÆËâ≤
      const candyColors = [
        0xffb3d9, // „Éî„É≥„ÇØ
        0xb3d9ff, // „Éñ„É´„Éº
        0xd9b3ff, // „Éë„Éº„Éó„É´
        0xffd9b3, // „Ç™„É¨„É≥„Ç∏
        0xb3ffd9, // „Éü„É≥„Éà
        0xfff0b3, // „Ç§„Ç®„É≠„Éº
      ];

      // „É≠„É™„Éù„ÉÉ„Éó„Ç≠„É£„É≥„Éá„Ç£
      const lollipops = [];
      for (let i = 0; i < 8; i++) {
        const group = new THREE.Group();

        // „Ç≠„É£„É≥„Éá„Ç£ÈÉ®ÂàÜÔºàÊ∏¶Â∑ª„ÅçÊ®°ÊßòÔºâ
        const candyGeometry = new THREE.CylinderGeometry(0.8, 0.8, 0.3, 32);
        const candyMaterial = new THREE.MeshPhongMaterial({
          color: candyColors[i % candyColors.length],
          shininess: 100,
          transparent: true,
          opacity: 0.9,
        });
        const candy = new THREE.Mesh(candyGeometry, candyMaterial);
        candy.rotation.x = Math.PI / 2;

        // Ê∏¶Â∑ª„ÅçÊ®°Êßò
        const spiralGeometry = new THREE.TorusGeometry(0.5, 0.1, 8, 32);
        const spiralMaterial = new THREE.MeshPhongMaterial({
          color: 0xffffff,
          shininess: 100,
          transparent: true,
          opacity: 0.7,
        });
        const spiral = new THREE.Mesh(spiralGeometry, spiralMaterial);
        spiral.rotation.x = Math.PI / 2;
        spiral.position.z = 0.2;

        // Ê£í
        const stickGeometry = new THREE.CylinderGeometry(0.08, 0.08, 2, 8);
        const stickMaterial = new THREE.MeshPhongMaterial({
          color: 0xffffff,
          shininess: 50,
        });
        const stick = new THREE.Mesh(stickGeometry, stickMaterial);
        stick.position.y = -1.2;

        group.add(candy);
        group.add(spiral);
        group.add(stick);

        const angle = (i / 8) * Math.PI * 2;
        const radius = 5;
        group.position.x = Math.cos(angle) * radius;
        group.position.z = Math.sin(angle) * radius;
        group.position.y = Math.sin(i) * 2;

        group.userData = {
          angle: angle,
          radius: radius,
          speed: 0.2 + Math.random() * 0.2,
          bobSpeed: 0.5 + Math.random() * 0.5,
          bobAmount: 0.3 + Math.random() * 0.3,
        };

        scene.add(group);
        lollipops.push(group);
      }

      // ‰∏∏„ÅÑ„Ç≠„É£„É≥„Éá„Ç£
      const roundCandies = [];
      for (let i = 0; i < 15; i++) {
        const size = 0.3 + Math.random() * 0.4;
        const geometry = new THREE.SphereGeometry(size, 16, 16);
        const material = new THREE.MeshPhongMaterial({
          color: candyColors[Math.floor(Math.random() * candyColors.length)],
          shininess: 120,
          transparent: true,
          opacity: 0.85,
        });

        const candy = new THREE.Mesh(geometry, material);
        candy.position.x = (Math.random() - 0.5) * 12;
        candy.position.y = Math.random() * 8 - 2;
        candy.position.z = (Math.random() - 0.5) * 8;

        candy.userData = {
          speedY: 0.005 + Math.random() * 0.01,
          rotationSpeed: (Math.random() - 0.5) * 0.02,
          floatOffset: Math.random() * Math.PI * 2,
        };

        scene.add(candy);
        roundCandies.push(candy);
      }

      // „Éâ„Éº„Éä„ÉÑÂûã„Ç≠„É£„É≥„Éá„Ç£
      const donutCandies = [];
      for (let i = 0; i < 6; i++) {
        const geometry = new THREE.TorusGeometry(0.6, 0.25, 16, 32);
        const material = new THREE.MeshPhongMaterial({
          color: candyColors[i % candyColors.length],
          shininess: 100,
          transparent: true,
          opacity: 0.9,
        });

        const donut = new THREE.Mesh(geometry, material);
        donut.position.x = (Math.random() - 0.5) * 10;
        donut.position.y = Math.random() * 6 - 1;
        donut.position.z = (Math.random() - 0.5) * 6;

        donut.userData = {
          rotationSpeedX: 0.005 + Math.random() * 0.01,
          rotationSpeedY: 0.005 + Math.random() * 0.01,
          floatSpeed: 0.3 + Math.random() * 0.3,
        };

        scene.add(donut);
        donutCandies.push(donut);
      }

      // „Ç≠„É©„Ç≠„É©„Éë„Éº„ÉÜ„Ç£„ÇØ„É´
      const sparklesGeometry = new THREE.BufferGeometry();
      const sparklesCount = 200;
      const sparklesPositions = new Float32Array(sparklesCount * 3);
      const sparklesColors = new Float32Array(sparklesCount * 3);

      for (let i = 0; i < sparklesCount; i++) {
        const i3 = i * 3;

        sparklesPositions[i3] = (Math.random() - 0.5) * 30;
        sparklesPositions[i3 + 1] = (Math.random() - 0.5) * 20;
        sparklesPositions[i3 + 2] = (Math.random() - 0.5) * 20;

        const color = new THREE.Color(
          candyColors[Math.floor(Math.random() * candyColors.length)]
        );
        sparklesColors[i3] = color.r;
        sparklesColors[i3 + 1] = color.g;
        sparklesColors[i3 + 2] = color.b;
      }

      sparklesGeometry.setAttribute(
        "position",
        new THREE.BufferAttribute(sparklesPositions, 3)
      );
      sparklesGeometry.setAttribute(
        "color",
        new THREE.BufferAttribute(sparklesColors, 3)
      );

      const sparklesMaterial = new THREE.PointsMaterial({
        size: 0.15,
        vertexColors: true,
        transparent: true,
        opacity: 0.7,
        blending: THREE.AdditiveBlending,
      });

      const sparkles = new THREE.Points(sparklesGeometry, sparklesMaterial);
      scene.add(sparkles);

      function animate() {
        requestAnimationFrame(animate);

        const t = performance.now() * 0.001;

        // „É≠„É™„Éù„ÉÉ„Éó„ÅÆÂõûËª¢
        lollipops.forEach((lollipop) => {
          const data = lollipop.userData;
          data.angle += data.speed * 0.01;

          lollipop.position.x = Math.cos(data.angle) * data.radius;
          lollipop.position.z = Math.sin(data.angle) * data.radius;
          lollipop.position.y = Math.sin(t * data.bobSpeed) * data.bobAmount;

          lollipop.rotation.z += 0.02;
        });

        // ‰∏∏„ÅÑ„Ç≠„É£„É≥„Éá„Ç£„ÅÆÂãï„Åç
        roundCandies.forEach((candy, index) => {
          const data = candy.userData;

          candy.position.y += data.speedY;
          candy.rotation.x += data.rotationSpeed;
          candy.rotation.y += data.rotationSpeed * 1.5;

          // ‰∏ä‰∏ãÈÅãÂãï
          candy.position.y += Math.sin(t * 2 + data.floatOffset) * 0.005;

          if (candy.position.y > 8) {
            candy.position.y = -2;
          }
        });

        // „Éâ„Éº„Éä„ÉÑ„ÅÆÂõûËª¢
        donutCandies.forEach((donut) => {
          const data = donut.userData;

          donut.rotation.x += data.rotationSpeedX;
          donut.rotation.y += data.rotationSpeedY;
          donut.position.y += Math.sin(t * data.floatSpeed) * 0.01;
        });

        // „Ç≠„É©„Ç≠„É©„ÅÆÁÇπÊªÖ
        sparkles.rotation.y = t * 0.05;
        const sparklesPos = sparklesGeometry.attributes.position.array;
        for (let i = 0; i < sparklesCount; i++) {
          const i3 = i * 3;
          sparklesPos[i3 + 1] += 0.02;
          if (sparklesPos[i3 + 1] > 10) {
            sparklesPos[i3 + 1] = -10;
          }
        }
        sparklesGeometry.attributes.position.needsUpdate = true;

        // „Ç´„É°„É©„ÅÆÂãï„Åç
        camera.position.x = Math.sin(t * 0.2) * 2;
        camera.position.y = 3 + Math.cos(t * 0.15) * 1;
        camera.lookAt(0, 0, 0);

        renderer.render(scene, camera);
      }
      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
