<!-- fragment_035_three.html -->
<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Fragment #136 ‚Äì Aurora</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
      body {
        margin: 0;
        background: linear-gradient(
          180deg,
          #000814 0%,
          #001d3d 20%,
          #002855 40%,
          #001d3d 60%,
          #000a1a 100%
        );
        overflow: hidden;
        height: 100vh;
      }

      .caption {
        position: fixed;
        left: 20px;
        bottom: 20px;
        font-family: "Helvetica Neue", sans-serif;
        font-size: 0.9rem;
        color: rgba(150, 255, 200, 0.9);
        z-index: 10;
        text-shadow: 0 2px 8px rgba(0, 255, 150, 0.8);
      }
    </style>
  </head>

  <body>
    <div class="caption">Fragment #136 ‚Äì "Aurora" üåå</div>

    <script>
      const scene = new THREE.Scene();

      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        200
      );
      camera.position.set(0, 5, 30);

      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);

      const ambientLight = new THREE.AmbientLight(0x224466, 0.3);
      scene.add(ambientLight);

      // Âú∞Âπ≥Á∑ö
      const groundGeometry = new THREE.PlaneGeometry(200, 200);
      const groundMaterial = new THREE.MeshPhongMaterial({
        color: 0x0a1a2a,
        shininess: 10,
      });
      const ground = new THREE.Mesh(groundGeometry, groundMaterial);
      ground.rotation.x = -Math.PI / 2;
      ground.position.y = -5;
      scene.add(ground);

      // Â±±„ÅÆ„Ç∑„É´„Ç®„ÉÉ„Éà
      const mountains = [];
      for (let i = 0; i < 8; i++) {
        const mountainGeometry = new THREE.ConeGeometry(
          5 + Math.random() * 5,
          10 + Math.random() * 15,
          4
        );
        const mountainMaterial = new THREE.MeshPhongMaterial({
          color: 0x0d1b2a,
          shininess: 5,
        });
        const mountain = new THREE.Mesh(mountainGeometry, mountainMaterial);

        mountain.position.x = (i - 4) * 15 + (Math.random() - 0.5) * 10;
        mountain.position.y = -5 + mountain.geometry.parameters.height / 2;
        mountain.position.z = -30 - Math.random() * 20;
        mountain.rotation.y = Math.random() * Math.PI * 2;

        scene.add(mountain);
        mountains.push(mountain);
      }

      // „Ç™„Éº„É≠„É©„ÅÆ„Ç´„Éº„ÉÜ„É≥„Çí‰ΩúÊàê
      function createAuroraCurtain(width, height, segments, color1, color2) {
        const geometry = new THREE.PlaneGeometry(
          width,
          height,
          segments,
          segments
        );
        const positions = geometry.attributes.position.array;

        // Ê≥¢ÂΩ¢„Çí‰Ωú„Çã
        for (let i = 0; i < positions.length; i += 3) {
          const x = positions[i];
          const y = positions[i + 1];
          positions[i + 2] = Math.sin(x * 0.3) * 2 + Math.sin(y * 0.2) * 1.5;
        }

        geometry.computeVertexNormals();

        const material = new THREE.ShaderMaterial({
          uniforms: {
            time: { value: 0 },
            color1: { value: new THREE.Color(color1) },
            color2: { value: new THREE.Color(color2) },
          },
          vertexShader: `
            uniform float time;
            varying vec2 vUv;
            varying float vWave;

            void main() {
              vUv = uv;
              vec3 pos = position;

              // Ê≥¢„ÅÆÂãï„Åç
              float wave1 = sin(pos.x * 0.3 + time * 0.5) * 2.0;
              float wave2 = sin(pos.y * 0.2 + time * 0.3) * 1.5;
              float wave3 = sin(pos.x * 0.5 + pos.y * 0.3 + time * 0.7) * 1.0;

              pos.z += wave1 + wave2 + wave3;
              vWave = wave1 + wave2;

              gl_Position = projectionMatrix * modelViewMatrix * vec4(pos, 1.0);
            }
          `,
          fragmentShader: `
            uniform float time;
            uniform vec3 color1;
            uniform vec3 color2;
            varying vec2 vUv;
            varying float vWave;

            void main() {
              // „Ç∞„É©„Éá„Éº„Ç∑„Éß„É≥
              float gradient = vUv.y;

              // Êè∫„Çâ„Åé
              float shimmer = sin(vUv.x * 10.0 + time * 2.0) * 0.5 + 0.5;
              shimmer *= sin(vUv.y * 8.0 - time * 1.5) * 0.5 + 0.5;

              // Ëâ≤„ÅÆ„Éü„ÉÉ„ÇØ„Çπ
              vec3 color = mix(color1, color2, gradient);

              // ÈÄèÊòéÂ∫¶
              float alpha = (0.3 + shimmer * 0.4) * (1.0 - vUv.y * 0.3);
              alpha *= smoothstep(0.0, 0.1, vUv.y) * smoothstep(1.0, 0.8, vUv.y);

              gl_FragColor = vec4(color, alpha);
            }
          `,
          transparent: true,
          side: THREE.DoubleSide,
          blending: THREE.AdditiveBlending,
        });

        const mesh = new THREE.Mesh(geometry, material);
        return mesh;
      }

      // Ë§áÊï∞„ÅÆ„Ç™„Éº„É≠„É©„Ç´„Éº„ÉÜ„É≥
      const auroras = [];
      const auroraConfigs = [
        { width: 60, height: 40, color1: 0x00ff88, color2: 0x0088ff, z: -40 },
        { width: 55, height: 35, color1: 0x88ff00, color2: 0x00ffaa, z: -35 },
        { width: 50, height: 45, color1: 0xff0088, color2: 0x8800ff, z: -30 },
        { width: 65, height: 38, color1: 0x00aaff, color2: 0xff00aa, z: -45 },
        { width: 45, height: 42, color1: 0xaaff00, color2: 0x00ffff, z: -25 },
      ];

      auroraConfigs.forEach((config, index) => {
        const aurora = createAuroraCurtain(
          config.width,
          config.height,
          64,
          config.color1,
          config.color2
        );

        aurora.position.y = 10;
        aurora.position.z = config.z;
        aurora.position.x = (index - 2) * 8;

        aurora.userData = {
          swaySpeed: 0.3 + Math.random() * 0.4,
          swayAmount: 0.5 + Math.random() * 0.5,
          offset: Math.random() * Math.PI * 2,
        };

        scene.add(aurora);
        auroras.push(aurora);
      });

      // Êòü
      const starsGeometry = new THREE.BufferGeometry();
      const starsCount = 800;
      const starsPositions = new Float32Array(starsCount * 3);
      const starsSizes = new Float32Array(starsCount);

      for (let i = 0; i < starsCount; i++) {
        const i3 = i * 3;

        // ‰∏äÂçäÂàÜ„Å´ÈõÜ‰∏≠
        starsPositions[i3] = (Math.random() - 0.5) * 200;
        starsPositions[i3 + 1] = Math.random() * 80 + 10;
        starsPositions[i3 + 2] = (Math.random() - 0.5) * 200 - 20;

        starsSizes[i] = Math.random() * 2 + 0.5;
      }

      starsGeometry.setAttribute(
        "position",
        new THREE.BufferAttribute(starsPositions, 3)
      );
      starsGeometry.setAttribute(
        "size",
        new THREE.BufferAttribute(starsSizes, 1)
      );

      const starsMaterial = new THREE.PointsMaterial({
        color: 0xffffff,
        size: 0.3,
        transparent: true,
        opacity: 0.8,
        sizeAttenuation: true,
      });

      const stars = new THREE.Points(starsGeometry, starsMaterial);
      scene.add(stars);

      // „Ç™„Éº„É≠„É©„ÅÆÂÖâ„ÅÆÁ≤íÂ≠ê
      const particleGeometry = new THREE.BufferGeometry();
      const particleCount = 500;
      const particlePositions = new Float32Array(particleCount * 3);
      const particleColors = new Float32Array(particleCount * 3);

      for (let i = 0; i < particleCount; i++) {
        const i3 = i * 3;

        particlePositions[i3] = (Math.random() - 0.5) * 100;
        particlePositions[i3 + 1] = Math.random() * 50 + 5;
        particlePositions[i3 + 2] = -Math.random() * 60 - 10;

        const colors = [0x00ff88, 0x0088ff, 0x88ff00, 0xff0088, 0x00ffaa];
        const color = new THREE.Color(
          colors[Math.floor(Math.random() * colors.length)]
        );
        particleColors[i3] = color.r;
        particleColors[i3 + 1] = color.g;
        particleColors[i3 + 2] = color.b;
      }

      particleGeometry.setAttribute(
        "position",
        new THREE.BufferAttribute(particlePositions, 3)
      );
      particleGeometry.setAttribute(
        "color",
        new THREE.BufferAttribute(particleColors, 3)
      );

      const particleMaterial = new THREE.PointsMaterial({
        size: 0.3,
        vertexColors: true,
        transparent: true,
        opacity: 0.6,
        blending: THREE.AdditiveBlending,
      });

      const particles = new THREE.Points(particleGeometry, particleMaterial);
      scene.add(particles);

      function animate() {
        requestAnimationFrame(animate);

        const t = performance.now() * 0.001;

        // „Ç™„Éº„É≠„É©„ÅÆÂãï„Åç
        auroras.forEach((aurora, index) => {
          const data = aurora.userData;

          // „Ç∑„Çß„Éº„ÉÄ„Éº„ÅÆÊôÇÈñì„ÇíÊõ¥Êñ∞
          aurora.material.uniforms.time.value = t;

          // Êè∫„Çå
          const sway =
            Math.sin(t * data.swaySpeed + data.offset) * data.swayAmount;
          aurora.rotation.y = sway * 0.1;
          aurora.position.x = (index - 2) * 8 + sway * 2;

          // „Ç∏„Ç™„É°„Éà„É™„ÅÆÊ≥¢ÂΩ¢Êõ¥Êñ∞
          const positions = aurora.geometry.attributes.position.array;
          for (let i = 0; i < positions.length; i += 3) {
            const x = positions[i];
            const y = positions[i + 1];
            const baseZ = Math.sin(x * 0.3) * 2 + Math.sin(y * 0.2) * 1.5;
            const wave = Math.sin(x * 0.2 + t * 0.5 + data.offset) * 1.5;
            positions[i + 2] = baseZ + wave;
          }
          aurora.geometry.attributes.position.needsUpdate = true;
        });

        // Êòü„ÅÆ„Åç„Çâ„ÇÅ„Åç
        const starPositions = starsGeometry.attributes.position.array;
        for (let i = 0; i < starsCount; i++) {
          const i3 = i * 3;
          const twinkle = Math.sin(t * 2 + i * 0.1) * 0.02;
          starPositions[i3 + 1] += twinkle;
        }
        starsGeometry.attributes.position.needsUpdate = true;

        // Á≤íÂ≠ê„ÅÆÂãï„Åç
        const particlePos = particleGeometry.attributes.position.array;
        for (let i = 0; i < particleCount; i++) {
          const i3 = i * 3;

          particlePos[i3] += Math.sin(t + i * 0.3) * 0.05;
          particlePos[i3 + 1] += Math.cos(t * 0.7 + i * 0.5) * 0.03;
          particlePos[i3 + 2] += Math.sin(t * 0.5 + i * 0.2) * 0.02;

          // „É™„Çª„ÉÉ„Éà
          if (
            Math.abs(particlePos[i3]) > 60 ||
            particlePos[i3 + 1] > 60 ||
            particlePos[i3 + 1] < 0 ||
            particlePos[i3 + 2] > -10
          ) {
            particlePos[i3] = (Math.random() - 0.5) * 100;
            particlePos[i3 + 1] = Math.random() * 50 + 5;
            particlePos[i3 + 2] = -Math.random() * 60 - 10;
          }
        }
        particleGeometry.attributes.position.needsUpdate = true;

        // „Ç´„É°„É©„ÅÆÂãï„Åç
        camera.position.x = Math.sin(t * 0.05) * 15;
        camera.position.y = 5 + Math.sin(t * 0.08) * 3;
        camera.lookAt(0, 10, -30);

        renderer.render(scene, camera);
      }
      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
