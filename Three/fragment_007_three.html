<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Fragment #110 – "Noise Terrain"</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
      body {
        margin: 0;
        background: #000;
        overflow: hidden;
        height: 100vh;
      }

      .caption {
        position: fixed;
        left: 20px;
        bottom: 20px;
        font-family: "Helvetica Neue", sans-serif;
        font-size: 0.9rem;
        color: rgba(255, 255, 255, 0.75);
        z-index: 10;
      }

      canvas {
        display: block;
      }
    </style>
  </head>

  <body>
    <div class="caption">Fragment #110 – "Noise Terrain"</div>

    <script>
      // シンプルなPerlin Noiseの実装
      class PerlinNoise {
        constructor(seed = Math.random()) {
          this.grad3 = [
            [1, 1, 0],
            [-1, 1, 0],
            [1, -1, 0],
            [-1, -1, 0],
            [1, 0, 1],
            [-1, 0, 1],
            [1, 0, -1],
            [-1, 0, -1],
            [0, 1, 1],
            [0, -1, 1],
            [0, 1, -1],
            [0, -1, -1],
          ];
          this.p = [];
          for (let i = 0; i < 256; i++) {
            this.p[i] = Math.floor(Math.random() * 256);
          }
          this.perm = [];
          for (let i = 0; i < 512; i++) {
            this.perm[i] = this.p[i & 255];
          }
        }

        dot(g, x, y, z) {
          return g[0] * x + g[1] * y + g[2] * z;
        }

        mix(a, b, t) {
          return (1 - t) * a + t * b;
        }

        fade(t) {
          return t * t * t * (t * (t * 6 - 15) + 10);
        }

        perlin3(x, y, z) {
          const X = Math.floor(x) & 255;
          const Y = Math.floor(y) & 255;
          const Z = Math.floor(z) & 255;

          x -= Math.floor(x);
          y -= Math.floor(y);
          z -= Math.floor(z);

          const u = this.fade(x);
          const v = this.fade(y);
          const w = this.fade(z);

          const A = this.perm[X] + Y;
          const AA = this.perm[A] + Z;
          const AB = this.perm[A + 1] + Z;
          const B = this.perm[X + 1] + Y;
          const BA = this.perm[B] + Z;
          const BB = this.perm[B + 1] + Z;

          return this.mix(
            this.mix(
              this.mix(
                this.dot(this.grad3[this.perm[AA] % 12], x, y, z),
                this.dot(this.grad3[this.perm[BA] % 12], x - 1, y, z),
                u
              ),
              this.mix(
                this.dot(this.grad3[this.perm[AB] % 12], x, y - 1, z),
                this.dot(this.grad3[this.perm[BB] % 12], x - 1, y - 1, z),
                u
              ),
              v
            ),
            this.mix(
              this.mix(
                this.dot(this.grad3[this.perm[AA + 1] % 12], x, y, z - 1),
                this.dot(this.grad3[this.perm[BA + 1] % 12], x - 1, y, z - 1),
                u
              ),
              this.mix(
                this.dot(this.grad3[this.perm[AB + 1] % 12], x, y - 1, z - 1),
                this.dot(
                  this.grad3[this.perm[BB + 1] % 12],
                  x - 1,
                  y - 1,
                  z - 1
                ),
                u
              ),
              v
            ),
            w
          );
        }
      }

      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        200
      );
      camera.position.set(0, 6, 10);
      camera.lookAt(0, 0, 0);

      const renderer = new THREE.WebGLRenderer({ antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);

      const noise = new PerlinNoise();

      const width = 150;
      const height = 150;
      const segments = 200;

      const geometry = new THREE.PlaneGeometry(
        width,
        height,
        segments,
        segments
      );
      geometry.rotateX(-Math.PI / 2);

      const pos = geometry.attributes.position;

      function updateTerrain(time) {
        for (let i = 0; i < pos.count; i++) {
          const x = pos.getX(i) / 15;
          const z = pos.getZ(i) / 15;

          const y =
            noise.perlin3(x + time * 0.2, z + time * 0.2, 0) * 2.2 +
            noise.perlin3(x * 0.5, z * 0.5, time * 0.1) * 1.2;

          pos.setY(i, y);
        }
        pos.needsUpdate = true;
        geometry.computeVertexNormals();
      }

      const material = new THREE.MeshStandardMaterial({
        color: 0x2277ff,
        wireframe: true,
        opacity: 0.9,
        transparent: true,
        emissive: 0x1155aa,
        emissiveIntensity: 0.3,
      });

      const terrain = new THREE.Mesh(geometry, material);
      scene.add(terrain);

      const ambientLight = new THREE.AmbientLight(0xffffff, 0.5);
      scene.add(ambientLight);

      const light = new THREE.PointLight(0xffffff, 1, 100);
      light.position.set(0, 10, 10);
      scene.add(light);

      function animate() {
        requestAnimationFrame(animate);

        const t = performance.now() * 0.0003;

        updateTerrain(t);

        camera.position.x = Math.sin(t * 0.2) * 12;
        camera.position.z = Math.cos(t * 0.2) * 12;
        camera.lookAt(0, 0, 0);

        renderer.render(scene, camera);
      }
      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
