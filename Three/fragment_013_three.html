<!-- fragment_013_three.html -->
<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Fragment #114 – Light Trails</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
      body {
        margin: 0;
        background: #000;
        overflow: hidden;
        height: 100vh;
      }

      .caption {
        position: fixed;
        left: 20px;
        bottom: 20px;
        font-family: "Helvetica Neue", sans-serif;
        font-size: 0.9rem;
        color: rgba(255, 255, 255, 0.75);
        z-index: 10;
      }
    </style>
  </head>

  <body>
    <div class="caption">Fragment #114 – "Light Trails"</div>

    <script>
      const scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0x000000, 10, 50);

      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        100
      );
      camera.position.set(0, 5, 15);
      camera.lookAt(0, 0, 0);

      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);

      // 光の軌跡を管理するクラス
      class LightTrail {
        constructor(color, pathFunction, speed, trailLength) {
          this.color = color;
          this.pathFunction = pathFunction;
          this.speed = speed;
          this.trailLength = trailLength;
          this.time = Math.random() * 100;
          this.points = [];

          // 軌跡用のジオメトリとマテリアル
          this.geometry = new THREE.BufferGeometry();
          this.material = new THREE.LineBasicMaterial({
            color: color,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
            linewidth: 2,
          });

          this.line = new THREE.Line(this.geometry, this.material);

          // グロー用の太い線
          this.glowGeometry = new THREE.BufferGeometry();
          this.glowMaterial = new THREE.LineBasicMaterial({
            color: color,
            transparent: true,
            opacity: 0.3,
            blending: THREE.AdditiveBlending,
            linewidth: 5,
          });

          this.glowLine = new THREE.Line(this.glowGeometry, this.glowMaterial);

          // 先端の光球
          const sphereGeometry = new THREE.SphereGeometry(0.15, 16, 16);
          const sphereMaterial = new THREE.MeshBasicMaterial({
            color: color,
            transparent: true,
            opacity: 0.9,
            blending: THREE.AdditiveBlending,
          });
          this.sphere = new THREE.Mesh(sphereGeometry, sphereMaterial);

          // グロー球
          const glowSphereGeometry = new THREE.SphereGeometry(0.3, 16, 16);
          const glowSphereMaterial = new THREE.MeshBasicMaterial({
            color: color,
            transparent: true,
            opacity: 0.4,
            blending: THREE.AdditiveBlending,
          });
          this.glowSphere = new THREE.Mesh(
            glowSphereGeometry,
            glowSphereMaterial
          );
        }

        update(deltaTime) {
          this.time += deltaTime * this.speed;

          // 現在位置を計算
          const currentPos = this.pathFunction(this.time);

          // 軌跡に追加
          this.points.push(currentPos.clone());

          // 軌跡の長さを制限
          if (this.points.length > this.trailLength) {
            this.points.shift();
          }

          // ジオメトリを更新
          if (this.points.length > 1) {
            const positions = new Float32Array(this.points.length * 3);
            const opacities = new Float32Array(this.points.length);

            for (let i = 0; i < this.points.length; i++) {
              positions[i * 3] = this.points[i].x;
              positions[i * 3 + 1] = this.points[i].y;
              positions[i * 3 + 2] = this.points[i].z;

              // 後ろほど透明に
              opacities[i] = i / this.points.length;
            }

            this.geometry.setAttribute(
              "position",
              new THREE.BufferAttribute(positions, 3)
            );
            this.glowGeometry.setAttribute(
              "position",
              new THREE.BufferAttribute(positions, 3)
            );
          }

          // 球体の位置を更新
          this.sphere.position.copy(currentPos);
          this.glowSphere.position.copy(currentPos);
        }

        addToScene(scene) {
          scene.add(this.line);
          scene.add(this.glowLine);
          scene.add(this.sphere);
          scene.add(this.glowSphere);
        }
      }

      // 様々な軌道パターン
      const helixPath = (t) => {
        return new THREE.Vector3(
          Math.cos(t) * 5,
          Math.sin(t * 2) * 3,
          Math.sin(t) * 5
        );
      };

      const wavePath = (t) => {
        return new THREE.Vector3(
          t * 2 - 10,
          Math.sin(t * 3) * 2 + Math.cos(t * 5) * 1,
          Math.cos(t * 2) * 3
        );
      };

      const spiralPath = (t) => {
        const radius = 3 + Math.sin(t * 0.5) * 2;
        return new THREE.Vector3(
          Math.cos(t * 2) * radius,
          t * 0.5 - 5,
          Math.sin(t * 2) * radius
        );
      };

      const torusPath = (t) => {
        const R = 5;
        const r = 2;
        return new THREE.Vector3(
          (R + r * Math.cos(t * 3)) * Math.cos(t),
          r * Math.sin(t * 3),
          (R + r * Math.cos(t * 3)) * Math.sin(t)
        );
      };

      const figurEightPath = (t) => {
        return new THREE.Vector3(
          Math.sin(t) * 5,
          Math.sin(t * 2) * 3,
          Math.cos(t) * 5
        );
      };

      const lissajousPath = (t) => {
        return new THREE.Vector3(
          Math.sin(t * 3) * 4,
          Math.sin(t * 2) * 3,
          Math.sin(t * 5) * 4
        );
      };

      // 光の軌跡を作成
      const trails = [
        new LightTrail(0xff3366, helixPath, 0.8, 150),
        new LightTrail(0x3366ff, wavePath, 0.6, 120),
        new LightTrail(0x33ff66, spiralPath, 0.7, 130),
        new LightTrail(0xffaa33, torusPath, 0.5, 140),
        new LightTrail(0xff33ff, figurEightPath, 0.9, 160),
        new LightTrail(0x33ffff, lissajousPath, 0.65, 135),
      ];

      trails.forEach((trail) => trail.addToScene(scene));

      // パーティクル背景
      const particlesGeometry = new THREE.BufferGeometry();
      const particlesCount = 500;
      const positions = new Float32Array(particlesCount * 3);
      const colors = new Float32Array(particlesCount * 3);

      for (let i = 0; i < particlesCount; i++) {
        const i3 = i * 3;
        const radius = 20 + Math.random() * 20;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.random() * Math.PI;

        positions[i3] = radius * Math.sin(phi) * Math.cos(theta);
        positions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
        positions[i3 + 2] = radius * Math.cos(phi);

        const color = new THREE.Color().setHSL(Math.random(), 0.7, 0.6);
        colors[i3] = color.r;
        colors[i3 + 1] = color.g;
        colors[i3 + 2] = color.b;
      }

      particlesGeometry.setAttribute(
        "position",
        new THREE.BufferAttribute(positions, 3)
      );
      particlesGeometry.setAttribute(
        "color",
        new THREE.BufferAttribute(colors, 3)
      );

      const particlesMaterial = new THREE.PointsMaterial({
        size: 0.08,
        vertexColors: true,
        transparent: true,
        opacity: 0.4,
        blending: THREE.AdditiveBlending,
      });

      const particles = new THREE.Points(particlesGeometry, particlesMaterial);
      scene.add(particles);

      let lastTime = performance.now();

      function animate() {
        requestAnimationFrame(animate);

        const currentTime = performance.now();
        const deltaTime = (currentTime - lastTime) * 0.001;
        lastTime = currentTime;

        const t = currentTime * 0.0003;

        // 各軌跡を更新
        trails.forEach((trail) => trail.update(deltaTime));

        // パーティクルを回転
        particles.rotation.y = t * 0.1;
        particles.rotation.x = t * 0.05;

        // カメラを動かす
        camera.position.x = Math.sin(t * 0.5) * 3;
        camera.position.y = 5 + Math.cos(t * 0.3) * 2;
        camera.lookAt(0, 0, 0);

        renderer.render(scene, camera);
      }
      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
