<!-- fragment_055_three.html -->
<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Demonic Ritual</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
      body {
        margin: 0;
        background: radial-gradient(circle, #1a0000 0%, #000000 100%);
        overflow: hidden;
        height: 100vh;
      }

      .caption {
        position: fixed;
        left: 20px;
        bottom: 20px;
        font-family: "Helvetica Neue", sans-serif;
        font-size: 0.9rem;
        color: rgba(200, 100, 100, 0.8);
        z-index: 10;
        text-shadow: 0 0 10px rgba(150, 50, 50, 0.5);
      }
    </style>
  </head>

  <body>
    <div class="caption">"Demonic Ritual" ğŸ”¥</div>

    <script>
      const scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0x0a0000, 5, 25);

      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        100
      );
      camera.position.set(0, 5, 12);
      camera.lookAt(0, 0, 0);

      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);

      // æš—èµ¤ã„ãƒ©ã‚¤ãƒ†ã‚£ãƒ³ã‚°
      const ambientLight = new THREE.AmbientLight(0x1a0000, 0.3);
      scene.add(ambientLight);

      // ä¸­å¤®ã®èµ¤ã„å…‰ï¼ˆå„€å¼ã®ä¸­å¿ƒï¼‰
      const ritualLight = new THREE.PointLight(0xff0000, 3, 30);
      ritualLight.position.set(0, 1, 0);
      scene.add(ritualLight);

      // é­”æ³•é™£
      const pentagram = new THREE.Group();

      // å¤–å††
      const outerCircleGeometry = new THREE.TorusGeometry(5, 0.1, 16, 64);
      const circleMaterial = new THREE.MeshBasicMaterial({
        color: 0xff0000,
        emissive: 0xff0000,
        emissiveIntensity: 0.8,
      });
      const outerCircle = new THREE.Mesh(outerCircleGeometry, circleMaterial);
      outerCircle.rotation.x = Math.PI / 2;
      pentagram.add(outerCircle);

      // å†…å††
      const innerCircleGeometry = new THREE.TorusGeometry(4, 0.08, 16, 64);
      const innerCircle = new THREE.Mesh(innerCircleGeometry, circleMaterial);
      innerCircle.rotation.x = Math.PI / 2;
      pentagram.add(innerCircle);

      // äº”èŠ’æ˜Ÿã®ç·š
      const starPoints = [];
      for (let i = 0; i < 5; i++) {
        const angle = (i * 2 * Math.PI) / 5 - Math.PI / 2;
        starPoints.push(
          new THREE.Vector3(Math.cos(angle) * 4.5, 0, Math.sin(angle) * 4.5)
        );
      }

      // äº”èŠ’æ˜Ÿã‚’æã
      const starIndices = [0, 2, 4, 1, 3, 0];
      for (let i = 0; i < starIndices.length - 1; i++) {
        const points = [];
        points.push(starPoints[starIndices[i]]);
        points.push(starPoints[starIndices[i + 1]]);

        const lineGeometry = new THREE.BufferGeometry().setFromPoints(points);
        const lineMaterial = new THREE.LineBasicMaterial({
          color: 0xff0000,
          linewidth: 3,
        });
        const line = new THREE.Line(lineGeometry, lineMaterial);
        pentagram.add(line);
      }

      // ãƒ«ãƒ¼ãƒ³æ–‡å­—é¢¨ã®è¨˜å·
      for (let i = 0; i < 5; i++) {
        const angle = (i * 2 * Math.PI) / 5 - Math.PI / 2;
        const runeGeometry = new THREE.PlaneGeometry(0.5, 0.7);
        const runeMaterial = new THREE.MeshBasicMaterial({
          color: 0xff0000,
          transparent: true,
          opacity: 0.8,
          side: THREE.DoubleSide,
        });
        const rune = new THREE.Mesh(runeGeometry, runeMaterial);
        rune.position.set(Math.cos(angle) * 4.7, 0.01, Math.sin(angle) * 4.7);
        rune.rotation.x = -Math.PI / 2;
        pentagram.add(rune);
      }

      pentagram.position.y = 0.02;
      scene.add(pentagram);

      // ã‚ã†ããï¼ˆ5æœ¬ï¼‰
      const candles = [];
      for (let i = 0; i < 5; i++) {
        const candle = new THREE.Group();

        const angle = (i * 2 * Math.PI) / 5 - Math.PI / 2;

        // ã‚ã†ããæœ¬ä½“
        const candleGeometry = new THREE.CylinderGeometry(0.15, 0.18, 1, 8);
        const candleMaterial = new THREE.MeshPhongMaterial({
          color: 0x2a0000,
          shininess: 10,
        });
        const candleBody = new THREE.Mesh(candleGeometry, candleMaterial);
        candleBody.position.y = 0.5;
        candle.add(candleBody);

        // ç‚
        const flameGeometry = new THREE.SphereGeometry(0.2, 8, 8);
        flameGeometry.scale(1, 1.8, 1);
        const flameMaterial = new THREE.MeshBasicMaterial({
          color: 0xff3300,
          transparent: true,
          opacity: 0.9,
          blending: THREE.AdditiveBlending,
        });
        const flame = new THREE.Mesh(flameGeometry, flameMaterial);
        flame.position.y = 1.2;
        candle.add(flame);

        // å…‰æº
        const candleLight = new THREE.PointLight(0xff3300, 1, 8);
        candleLight.position.y = 1.2;
        candle.add(candleLight);

        candle.position.set(Math.cos(angle) * 5.5, 0, Math.sin(angle) * 5.5);

        candle.userData = { flame: flame, light: candleLight };

        scene.add(candle);
        candles.push(candle);
      }

      // æµ®éŠã™ã‚‹é ­è“‹éª¨
      const floatingSkulls = [];
      for (let i = 0; i < 8; i++) {
        const skull = new THREE.Group();

        // é ­è“‹éª¨
        const skullGeometry = new THREE.SphereGeometry(0.3, 16, 16);
        const skullMaterial = new THREE.MeshPhongMaterial({
          color: 0xccccaa,
          shininess: 20,
          emissive: 0x330000,
          emissiveIntensity: 0.2,
        });
        const skullMesh = new THREE.Mesh(skullGeometry, skullMaterial);
        skull.add(skullMesh);

        // ç›®ã®ç©´ï¼ˆèµ¤ãå…‰ã‚‹ï¼‰
        const eyeGeometry = new THREE.SphereGeometry(0.08, 8, 8);
        const eyeMaterial = new THREE.MeshBasicMaterial({
          color: 0xff0000,
          transparent: true,
          opacity: 0.9,
        });

        const leftEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        leftEye.position.set(-0.12, 0.05, 0.25);
        skull.add(leftEye);

        const rightEye = new THREE.Mesh(eyeGeometry, eyeMaterial);
        rightEye.position.set(0.12, 0.05, 0.25);
        skull.add(rightEye);

        // é¡
        const jawGeometry = new THREE.SphereGeometry(0.25, 16, 16);
        jawGeometry.scale(1, 0.5, 0.8);
        const jaw = new THREE.Mesh(jawGeometry, skullMaterial);
        jaw.position.y = -0.25;
        skull.add(jaw);

        const angle = (i / 8) * Math.PI * 2;
        const radius = 7 + Math.random() * 2;
        skull.position.set(
          Math.cos(angle) * radius,
          2 + Math.random() * 3,
          Math.sin(angle) * radius
        );

        skull.userData = {
          angle: angle,
          radius: radius,
          speed: 0.1 + Math.random() * 0.1,
          bobSpeed: 0.5 + Math.random() * 0.5,
          bobAmount: 0.3 + Math.random() * 0.3,
        };

        scene.add(skull);
        floatingSkulls.push(skull);
      }

      // æ‚ªé­”ã®ç›®ï¼ˆå·¨å¤§ãªç›®ï¼‰
      const demonicEyes = [];
      for (let i = 0; i < 3; i++) {
        const eye = new THREE.Group();

        // çœ¼çƒ
        const eyeballGeometry = new THREE.SphereGeometry(0.5, 32, 32);
        const eyeballMaterial = new THREE.MeshPhongMaterial({
          color: 0xff0000,
          shininess: 100,
          emissive: 0x660000,
          emissiveIntensity: 0.5,
        });
        const eyeball = new THREE.Mesh(eyeballGeometry, eyeballMaterial);
        eye.add(eyeball);

        // ç³å­”
        const pupilGeometry = new THREE.SphereGeometry(0.2, 16, 16);
        const pupilMaterial = new THREE.MeshBasicMaterial({
          color: 0x000000,
        });
        const pupil = new THREE.Mesh(pupilGeometry, pupilMaterial);
        pupil.position.z = 0.4;
        eye.add(pupil);

        // ã‚°ãƒ­ãƒ¼
        const glowGeometry = new THREE.SphereGeometry(0.7, 32, 32);
        const glowMaterial = new THREE.MeshBasicMaterial({
          color: 0xff0000,
          transparent: true,
          opacity: 0.3,
          blending: THREE.AdditiveBlending,
        });
        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
        eye.add(glow);

        eye.position.set((i - 1) * 3, 4 + Math.random() * 2, -8);

        eye.userData = {
          pupil: pupil,
          lookSpeed: 0.5 + Math.random() * 0.5,
        };

        scene.add(eye);
        demonicEyes.push(eye);
      }

      // è¡€ã®é›¨ï¼ˆãƒ‘ãƒ¼ãƒ†ã‚£ã‚¯ãƒ«ï¼‰
      const bloodRainGeometry = new THREE.BufferGeometry();
      const bloodCount = 200;
      const bloodPositions = new Float32Array(bloodCount * 3);

      for (let i = 0; i < bloodCount; i++) {
        const i3 = i * 3;

        bloodPositions[i3] = (Math.random() - 0.5) * 30;
        bloodPositions[i3 + 1] = Math.random() * 15;
        bloodPositions[i3 + 2] = (Math.random() - 0.5) * 30;
      }

      bloodRainGeometry.setAttribute(
        "position",
        new THREE.BufferAttribute(bloodPositions, 3)
      );

      const bloodMaterial = new THREE.PointsMaterial({
        size: 0.15,
        color: 0x660000,
        transparent: true,
        opacity: 0.8,
      });

      const bloodRain = new THREE.Points(bloodRainGeometry, bloodMaterial);
      scene.add(bloodRain);

      // å¬å–šã®ç…™
      const smokeParticles = [];
      for (let i = 0; i < 20; i++) {
        const smokeGeometry = new THREE.SphereGeometry(0.5, 8, 8);
        const smokeMaterial = new THREE.MeshBasicMaterial({
          color: 0x330000,
          transparent: true,
          opacity: 0.4,
          blending: THREE.AdditiveBlending,
        });
        const smoke = new THREE.Mesh(smokeGeometry, smokeMaterial);

        smoke.position.set(
          (Math.random() - 0.5) * 2,
          Math.random() * 2,
          (Math.random() - 0.5) * 2
        );

        smoke.userData = {
          speed: 0.02 + Math.random() * 0.03,
          rotationSpeed: (Math.random() - 0.5) * 0.02,
        };

        scene.add(smoke);
        smokeParticles.push(smoke);
      }

      // åºŠ
      const floorGeometry = new THREE.CircleGeometry(15, 32);
      const floorMaterial = new THREE.MeshPhongMaterial({
        color: 0x1a0000,
        shininess: 20,
      });
      const floor = new THREE.Mesh(floorGeometry, floorMaterial);
      floor.rotation.x = -Math.PI / 2;
      scene.add(floor);

      function animate() {
        requestAnimationFrame(animate);

        const t = performance.now() * 0.001;

        // é­”æ³•é™£ã®å›è»¢ã¨è„ˆå‹•
        pentagram.rotation.y = t * 0.2;
        const pulse = 1 + Math.sin(t * 3) * 0.05;
        pentagram.scale.set(pulse, 1, pulse);

        // ä¸­å¤®ã®å…‰ã®è„ˆå‹•
        ritualLight.intensity = 2.5 + Math.sin(t * 4) * 0.5;

        // ã‚ã†ããã®ç‚ã®æºã‚‰ã
        candles.forEach((candle, index) => {
          const flame = candle.userData.flame;
          const light = candle.userData.light;

          flame.scale.y = 1 + Math.sin(t * 5 + index) * 0.3;
          light.intensity = 0.8 + Math.sin(t * 5 + index) * 0.2;
        });

        // é ­è“‹éª¨ã®å›è»¢
        floatingSkulls.forEach((skull) => {
          const data = skull.userData;
          data.angle += data.speed * 0.01;

          skull.position.x = Math.cos(data.angle) * data.radius;
          skull.position.z = Math.sin(data.angle) * data.radius;
          skull.position.y += Math.sin(t * data.bobSpeed) * 0.01;

          skull.lookAt(0, skull.position.y, 0);
        });

        // æ‚ªé­”ã®ç›®ã®å‹•ã
        demonicEyes.forEach((eye) => {
          const data = eye.userData;

          // ã‚«ãƒ¡ãƒ©ã‚’è¿½ã†
          eye.lookAt(camera.position);

          // ç³å­”ã®å‹•ã
          const lookX = Math.sin(t * data.lookSpeed) * 0.2;
          const lookY = Math.cos(t * data.lookSpeed * 0.7) * 0.2;
          data.pupil.position.x = lookX;
          data.pupil.position.y = lookY;
        });

        // è¡€ã®é›¨
        const bloodPos = bloodRainGeometry.attributes.position.array;
        for (let i = 0; i < bloodCount; i++) {
          const i3 = i * 3;
          bloodPos[i3 + 1] -= 0.05;

          if (bloodPos[i3 + 1] < 0) {
            bloodPos[i3 + 1] = 15;
          }
        }
        bloodRainGeometry.attributes.position.needsUpdate = true;

        // å¬å–šã®ç…™
        smokeParticles.forEach((smoke) => {
          const data = smoke.userData;
          smoke.position.y += data.speed;
          smoke.rotation.y += data.rotationSpeed;

          if (smoke.position.y > 8) {
            smoke.position.y = 0;
            smoke.position.x = (Math.random() - 0.5) * 2;
            smoke.position.z = (Math.random() - 0.5) * 2;
          }

          smoke.material.opacity = 0.4 - (smoke.position.y / 8) * 0.4;
        });

        // ã‚«ãƒ¡ãƒ©ã®ä¸æ°—å‘³ãªå›è»¢
        camera.position.x = Math.sin(t * 0.15) * 12;
        camera.position.z = Math.cos(t * 0.15) * 12;
        camera.position.y = 5 + Math.sin(t * 0.2) * 1;
        camera.lookAt(0, 1, 0);

        renderer.render(scene, camera);
      }
      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
