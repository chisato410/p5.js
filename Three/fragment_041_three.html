<!-- fragment_041_three.html -->
<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Fragment #142 â€“ Liquid Geometry</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
      body {
        margin: 0;
        background: linear-gradient(
          180deg,
          #000000 0%,
          #1a0033 50%,
          #000000 100%
        );
        overflow: hidden;
        height: 100vh;
      }

      .caption {
        position: fixed;
        left: 20px;
        bottom: 20px;
        font-family: "Helvetica Neue", sans-serif;
        font-size: 0.9rem;
        color: rgba(255, 255, 255, 0.9);
        z-index: 10;
        text-shadow: 0 2px 8px rgba(128, 0, 255, 0.8);
      }
    </style>
  </head>

  <body>
    <div class="caption">Fragment #142 â€“ "Liquid Geometry" ğŸŒŠ</div>

    <script>
      const scene = new THREE.Scene();

      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        200
      );
      camera.position.set(0, 0, 30);

      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);

      // æ¶²ä½“ã®ã‚ˆã†ã«å¤‰å½¢ã™ã‚‹å¹¾ä½•å­¦å›³å½¢ã‚’ä½œæˆ
      function createLiquidShape(type, size, color) {
        const shape = new THREE.Group();

        let geometry;
        switch (type) {
          case "cube":
            geometry = new THREE.BoxGeometry(size, size, size, 20, 20, 20);
            break;
          case "sphere":
            geometry = new THREE.SphereGeometry(size, 32, 32);
            break;
          case "torus":
            geometry = new THREE.TorusGeometry(size, size * 0.4, 32, 64);
            break;
          case "icosahedron":
            geometry = new THREE.IcosahedronGeometry(size, 3);
            break;
          case "octahedron":
            geometry = new THREE.OctahedronGeometry(size, 3);
            break;
        }

        // é ‚ç‚¹ã®åˆæœŸä½ç½®ã‚’ä¿å­˜
        const originalPositions = geometry.attributes.position.array.slice();
        geometry.userData.originalPositions = originalPositions;

        const material = new THREE.MeshPhongMaterial({
          color: color,
          emissive: color,
          emissiveIntensity: 0.3,
          shininess: 100,
          transparent: true,
          opacity: 0.8,
          side: THREE.DoubleSide,
        });

        const mesh = new THREE.Mesh(geometry, material);
        shape.add(mesh);

        // ãƒ¯ã‚¤ãƒ¤ãƒ¼ãƒ•ãƒ¬ãƒ¼ãƒ 
        const wireGeometry = new THREE.EdgesGeometry(geometry);
        const wireMaterial = new THREE.LineBasicMaterial({
          color: 0xffffff,
          transparent: true,
          opacity: 0.3,
          blending: THREE.AdditiveBlending,
        });
        const wireframe = new THREE.LineSegments(wireGeometry, wireMaterial);
        shape.add(wireframe);

        return shape;
      }

      // è¤‡æ•°ã®æ¶²ä½“å›³å½¢
      const liquidShapes = [];
      const shapeTypes = [
        "cube",
        "sphere",
        "torus",
        "icosahedron",
        "octahedron",
      ];
      const colors = [0xff00ff, 0x00ffff, 0xffff00, 0xff0080, 0x80ff00];

      for (let i = 0; i < 8; i++) {
        const type = shapeTypes[i % shapeTypes.length];
        const size = 2 + Math.random() * 2;
        const color = colors[i % colors.length];
        const shape = createLiquidShape(type, size, color);

        const angle = (i / 8) * Math.PI * 2;
        const radius = 12;
        shape.position.x = Math.cos(angle) * radius;
        shape.position.y = Math.sin(angle) * radius;
        shape.position.z = (Math.random() - 0.5) * 10;

        shape.userData = {
          angle: angle,
          radius: radius,
          orbitSpeed: 0.3 + Math.random() * 0.5,
          rotateSpeedX: (Math.random() - 0.5) * 0.02,
          rotateSpeedY: (Math.random() - 0.5) * 0.02,
          rotateSpeedZ: (Math.random() - 0.5) * 0.02,
          liquidSpeed: 0.5 + Math.random() * 1,
          liquidAmount: 0.3 + Math.random() * 0.5,
          morphSpeed: 0.2 + Math.random() * 0.3,
        };

        scene.add(shape);
        liquidShapes.push(shape);
      }

      // ãƒ¡ã‚¿ãƒœãƒ¼ãƒ«ã®ã‚ˆã†ãªçƒä½“ç¾¤
      const metaballs = [];
      for (let i = 0; i < 20; i++) {
        const ballGeometry = new THREE.SphereGeometry(
          0.5 + Math.random() * 1,
          32,
          32
        );
        const hue = Math.random();
        const color = new THREE.Color().setHSL(hue, 1, 0.5);
        const ballMaterial = new THREE.MeshPhongMaterial({
          color: color,
          emissive: color,
          emissiveIntensity: 0.5,
          shininess: 100,
          transparent: true,
          opacity: 0.6,
        });
        const ball = new THREE.Mesh(ballGeometry, ballMaterial);

        ball.position.x = (Math.random() - 0.5) * 30;
        ball.position.y = (Math.random() - 0.5) * 30;
        ball.position.z = (Math.random() - 0.5) * 30;

        ball.userData = {
          hue: hue,
          velocityX: (Math.random() - 0.5) * 0.1,
          velocityY: (Math.random() - 0.5) * 0.1,
          velocityZ: (Math.random() - 0.5) * 0.1,
          pulseSpeed: 1 + Math.random() * 2,
          pulseOffset: Math.random() * Math.PI * 2,
        };

        scene.add(ball);
        metaballs.push(ball);
      }

      // æ¶²ä½“ã®é£›æ²«
      const splashGeometry = new THREE.BufferGeometry();
      const splashCount = 500;
      const splashPositions = new Float32Array(splashCount * 3);
      const splashColors = new Float32Array(splashCount * 3);
      const splashVelocities = [];

      for (let i = 0; i < splashCount; i++) {
        const i3 = i * 3;

        splashPositions[i3] = (Math.random() - 0.5) * 50;
        splashPositions[i3 + 1] = (Math.random() - 0.5) * 50;
        splashPositions[i3 + 2] = (Math.random() - 0.5) * 50;

        const hue = Math.random();
        const color = new THREE.Color().setHSL(hue, 1, 0.5);
        splashColors[i3] = color.r;
        splashColors[i3 + 1] = color.g;
        splashColors[i3 + 2] = color.b;

        splashVelocities.push({
          x: (Math.random() - 0.5) * 0.2,
          y: (Math.random() - 0.5) * 0.2,
          z: (Math.random() - 0.5) * 0.2,
        });
      }

      splashGeometry.setAttribute(
        "position",
        new THREE.BufferAttribute(splashPositions, 3)
      );
      splashGeometry.setAttribute(
        "color",
        new THREE.BufferAttribute(splashColors, 3)
      );

      const splashMaterial = new THREE.PointsMaterial({
        size: 0.3,
        vertexColors: true,
        transparent: true,
        opacity: 0.8,
        blending: THREE.AdditiveBlending,
      });

      const splash = new THREE.Points(splashGeometry, splashMaterial);
      scene.add(splash);

      // ãƒ©ã‚¤ãƒˆ
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
      scene.add(ambientLight);

      const lights = [];
      for (let i = 0; i < 6; i++) {
        const hue = i / 6;
        const color = new THREE.Color().setHSL(hue, 1, 0.5);
        const light = new THREE.PointLight(color, 2, 40);

        const angle = (i / 6) * Math.PI * 2;
        light.position.x = Math.cos(angle) * 20;
        light.position.y = Math.sin(angle) * 20;
        light.position.z = 0;

        scene.add(light);
        lights.push(light);
      }

      function animate() {
        requestAnimationFrame(animate);

        const t = performance.now() * 0.001;

        // æ¶²ä½“å›³å½¢ã®å¤‰å½¢
        liquidShapes.forEach((shape, index) => {
          const data = shape.userData;

          // è»Œé“é‹å‹•
          data.angle += data.orbitSpeed * 0.01;
          shape.position.x = Math.cos(data.angle) * data.radius;
          shape.position.y = Math.sin(data.angle) * data.radius;

          // å›è»¢
          shape.rotation.x += data.rotateSpeedX;
          shape.rotation.y += data.rotateSpeedY;
          shape.rotation.z += data.rotateSpeedZ;

          // æ¶²ä½“å¤‰å½¢
          const mesh = shape.children[0];
          const geometry = mesh.geometry;
          const positions = geometry.attributes.position.array;
          const originalPositions = geometry.userData.originalPositions;

          for (let i = 0; i < positions.length; i += 3) {
            const x = originalPositions[i];
            const y = originalPositions[i + 1];
            const z = originalPositions[i + 2];

            const distance = Math.sqrt(x * x + y * y + z * z);
            const wave1 =
              Math.sin(t * data.liquidSpeed + distance * 0.5 + index) *
              data.liquidAmount;
            const wave2 =
              Math.cos(t * data.liquidSpeed * 1.3 + x * 0.3 + y * 0.3) *
              data.liquidAmount *
              0.5;

            positions[i] = x * (1 + wave1 + wave2);
            positions[i + 1] = y * (1 + wave1 - wave2);
            positions[i + 2] = z * (1 + wave1 + wave2 * 0.5);
          }
          geometry.attributes.position.needsUpdate = true;
          geometry.computeVertexNormals();

          // è‰²ã®å¤‰åŒ–
          const hue = (t * 0.1 + index * 0.1) % 1;
          const color = new THREE.Color().setHSL(hue, 1, 0.5);
          mesh.material.color.copy(color);
          mesh.material.emissive.copy(color);

          // ãƒ¢ãƒ¼ãƒ•ã‚£ãƒ³ã‚°åŠ¹æœ
          const morph = Math.sin(t * data.morphSpeed + index) * 0.5 + 0.5;
          mesh.material.opacity = 0.6 + morph * 0.3;
        });

        // ãƒ¡ã‚¿ãƒœãƒ¼ãƒ«ã®å‹•ã
        metaballs.forEach((ball, index) => {
          const data = ball.userData;

          // ç§»å‹•
          ball.position.x += data.velocityX;
          ball.position.y += data.velocityY;
          ball.position.z += data.velocityZ;

          // å¢ƒç•Œã§ãƒã‚¦ãƒ³ã‚¹
          if (Math.abs(ball.position.x) > 20) data.velocityX *= -1;
          if (Math.abs(ball.position.y) > 20) data.velocityY *= -1;
          if (Math.abs(ball.position.z) > 20) data.velocityZ *= -1;

          // è„ˆå‹•
          const pulse =
            Math.sin(t * data.pulseSpeed + data.pulseOffset) * 0.5 + 0.5;
          ball.scale.setScalar(1 + pulse * 0.5);

          // è‰²ã®å¤‰åŒ–
          const hue = (data.hue + t * 0.1) % 1;
          const color = new THREE.Color().setHSL(hue, 1, 0.5);
          ball.material.color.copy(color);
          ball.material.emissive.copy(color);
          ball.material.opacity = 0.4 + pulse * 0.4;
        });

        // é£›æ²«ã®å‹•ã
        const splashPos = splashGeometry.attributes.position.array;
        const splashCol = splashGeometry.attributes.color.array;

        for (let i = 0; i < splashCount; i++) {
          const i3 = i * 3;
          const vel = splashVelocities[i];

          splashPos[i3] += vel.x;
          splashPos[i3 + 1] += vel.y;
          splashPos[i3 + 2] += vel.z;

          // ãƒªã‚»ãƒƒãƒˆ
          if (
            Math.abs(splashPos[i3]) > 30 ||
            Math.abs(splashPos[i3 + 1]) > 30 ||
            Math.abs(splashPos[i3 + 2]) > 30
          ) {
            splashPos[i3] = (Math.random() - 0.5) * 10;
            splashPos[i3 + 1] = (Math.random() - 0.5) * 10;
            splashPos[i3 + 2] = (Math.random() - 0.5) * 10;

            vel.x = (Math.random() - 0.5) * 0.2;
            vel.y = (Math.random() - 0.5) * 0.2;
            vel.z = (Math.random() - 0.5) * 0.2;
          }

          // è‰²ã®å¤‰åŒ–
          const hue = (t * 0.2 + i * 0.01) % 1;
          const color = new THREE.Color().setHSL(hue, 1, 0.5);
          splashCol[i3] = color.r;
          splashCol[i3 + 1] = color.g;
          splashCol[i3 + 2] = color.b;
        }
        splashGeometry.attributes.position.needsUpdate = true;
        splashGeometry.attributes.color.needsUpdate = true;

        // ãƒ©ã‚¤ãƒˆã®å‹•ã
        lights.forEach((light, index) => {
          const angle = t * 0.5 + (index / lights.length) * Math.PI * 2;
          light.position.x = Math.cos(angle) * 20;
          light.position.y = Math.sin(angle) * 20;
          light.position.z = Math.sin(t + index) * 10;

          const hue = (t * 0.1 + index / lights.length) % 1;
          light.color.setHSL(hue, 1, 0.5);
        });

        // ã‚«ãƒ¡ãƒ©ã®å‹•ã
        camera.position.x = Math.sin(t * 0.15) * 35;
        camera.position.y = Math.cos(t * 0.2) * 25;
        camera.position.z = 30 + Math.sin(t * 0.1) * 10;
        camera.lookAt(0, 0, 0);

        renderer.render(scene, camera);
      }
      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
