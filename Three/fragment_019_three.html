<!-- fragment_019_three.html -->
<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Fragment #120 – Shell Surface</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
      body {
        margin: 0;
        background: linear-gradient(135deg, #0a0015 0%, #1a0030 100%);
        overflow: hidden;
        height: 100vh;
      }

      .caption {
        position: fixed;
        left: 20px;
        bottom: 20px;
        font-family: "Helvetica Neue", sans-serif;
        font-size: 0.9rem;
        color: rgba(255, 255, 255, 0.75);
        z-index: 10;
      }
    </style>
  </head>

  <body>
    <div class="caption">Fragment #120 – "Shell Surface" (シェル曲面)</div>

    <script>
      const scene = new THREE.Scene();
      scene.fog = new THREE.Fog(0x0a0015, 10, 40);

      const camera = new THREE.PerspectiveCamera(
        60,
        window.innerWidth / window.innerHeight,
        0.1,
        100
      );
      camera.position.set(0, 0, 12);

      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);

      // ライティング
      const ambientLight = new THREE.AmbientLight(0xffffff, 0.3);
      scene.add(ambientLight);

      const light1 = new THREE.PointLight(0x4488ff, 2, 50);
      light1.position.set(10, 10, 10);
      scene.add(light1);

      const light2 = new THREE.PointLight(0xff4488, 1.5, 50);
      light2.position.set(-10, -5, 5);
      scene.add(light2);

      // シェル曲面
      function shellSurface(u, v, target) {
        u = u * Math.PI * 2;
        v = v * Math.PI * 2;

        const a = 1;
        const b = 1;
        const c = 0.5;
        const n = 2;

        const r = a * (1 - v / (Math.PI * 2)) * (1 + Math.cos(u));

        target.x = r * Math.cos(n * v);
        target.y = r * Math.sin(n * v);
        target.z = b * v + c * r * Math.sin(u);

        target.multiplyScalar(0.8);
      }

      const geometry = new THREE.ParametricGeometry(shellSurface, 100, 100);

      // カラフルな頂点カラー
      const colors = [];
      const positions = geometry.attributes.position;

      for (let i = 0; i < positions.count; i++) {
        const x = positions.getX(i);
        const y = positions.getY(i);
        const z = positions.getZ(i);

        const distance = Math.sqrt(x * x + y * y + z * z);
        const hue = (distance / 10) % 1;

        const color = new THREE.Color().setHSL(hue, 0.8, 0.6);
        colors.push(color.r, color.g, color.b);
      }

      geometry.setAttribute(
        "color",
        new THREE.Float32BufferAttribute(colors, 3)
      );

      const material = new THREE.MeshPhongMaterial({
        vertexColors: true,
        side: THREE.DoubleSide,
        shininess: 80,
        specular: 0x666666,
        transparent: true,
        opacity: 0.9,
      });

      const mesh = new THREE.Mesh(geometry, material);

      // ワイヤーフレーム
      const wireframeGeometry = geometry.clone();
      const wireframeMaterial = new THREE.MeshBasicMaterial({
        color: 0xffffff,
        wireframe: true,
        transparent: true,
        opacity: 0.15,
      });
      const wireframe = new THREE.Mesh(wireframeGeometry, wireframeMaterial);

      const group = new THREE.Group();
      group.add(mesh);
      group.add(wireframe);
      scene.add(group);

      // パーティクル
      const particlesGeometry = new THREE.BufferGeometry();
      const particlesCount = 1000;
      const particlePositions = new Float32Array(particlesCount * 3);
      const particleColors = new Float32Array(particlesCount * 3);

      for (let i = 0; i < particlesCount; i++) {
        const i3 = i * 3;
        const radius = 15 + Math.random() * 10;
        const theta = Math.random() * Math.PI * 2;
        const phi = Math.random() * Math.PI;

        particlePositions[i3] = radius * Math.sin(phi) * Math.cos(theta);
        particlePositions[i3 + 1] = radius * Math.sin(phi) * Math.sin(theta);
        particlePositions[i3 + 2] = radius * Math.cos(phi);

        const color = new THREE.Color().setHSL(Math.random(), 0.7, 0.6);
        particleColors[i3] = color.r;
        particleColors[i3 + 1] = color.g;
        particleColors[i3 + 2] = color.b;
      }

      particlesGeometry.setAttribute(
        "position",
        new THREE.BufferAttribute(particlePositions, 3)
      );
      particlesGeometry.setAttribute(
        "color",
        new THREE.BufferAttribute(particleColors, 3)
      );

      const particlesMaterial = new THREE.PointsMaterial({
        size: 0.05,
        vertexColors: true,
        transparent: true,
        opacity: 0.5,
        blending: THREE.AdditiveBlending,
      });

      const particles = new THREE.Points(particlesGeometry, particlesMaterial);
      scene.add(particles);

      function animate() {
        requestAnimationFrame(animate);

        const t = performance.now() * 0.0003;

        // 曲面を回転
        group.rotation.y = t * 0.5;
        group.rotation.x = Math.sin(t * 0.3) * 0.3;

        // 頂点カラーを更新
        const meshColors = geometry.attributes.color;

        for (let i = 0; i < meshColors.count; i++) {
          const x = positions.getX(i);
          const y = positions.getY(i);
          const z = positions.getZ(i);

          const distance = Math.sqrt(x * x + y * y + z * z);
          const hue = (distance / 10 + t) % 1;

          const color = new THREE.Color().setHSL(hue, 0.8, 0.6);
          meshColors.setXYZ(i, color.r, color.g, color.b);
        }
        meshColors.needsUpdate = true;

        // パーティクルを回転
        particles.rotation.y = t * 0.1;
        particles.rotation.x = t * 0.05;

        // ライトを動かす
        light1.position.x = Math.cos(t) * 10;
        light1.position.z = Math.sin(t) * 10;

        light2.position.x = Math.cos(t + Math.PI) * 10;
        light2.position.z = Math.sin(t + Math.PI) * 10;

        // カメラを動かす
        camera.position.x = Math.sin(t * 0.3) * 2;
        camera.position.y = Math.cos(t * 0.2) * 2;
        camera.lookAt(0, 0, 0);

        renderer.render(scene, camera);
      }
      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
