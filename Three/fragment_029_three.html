<!DOCTYPE html>
<html lang="ja">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Fragment #130 ‚Äì Floating Lanterns</title>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>

    <style>
      body {
        margin: 0;
        background: linear-gradient(
          180deg,
          #0a0520 0%,
          #1a0f3a 30%,
          #2d1b4e 60%,
          #4a2c5a 100%
        );
        overflow: hidden;
        height: 100vh;
      }

      .caption {
        position: fixed;
        left: 20px;
        bottom: 20px;
        font-family: "Helvetica Neue", sans-serif;
        font-size: 0.9rem;
        color: rgba(255, 200, 150, 0.9);
        z-index: 10;
        text-shadow: 0 2px 4px rgba(0, 0, 0, 0.8);
      }
    </style>
  </head>

  <body>
    <div class="caption">Fragment #130 ‚Äì "Floating Lanterns" üèÆ</div>

    <script>
      const scene = new THREE.Scene();
      scene.fog = new THREE.FogExp2(0x1a0f3a, 0.02);

      const camera = new THREE.PerspectiveCamera(
        75,
        window.innerWidth / window.innerHeight,
        0.1,
        200
      );
      camera.position.set(0, 5, 20);

      const renderer = new THREE.WebGLRenderer({
        antialias: true,
        alpha: true,
      });
      renderer.setSize(window.innerWidth, window.innerHeight);
      renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
      document.body.appendChild(renderer.domElement);

      const ambientLight = new THREE.AmbientLight(0x4a2c5a, 0.3);
      scene.add(ambientLight);

      function createLantern(size, color, glowColor) {
        const lantern = new THREE.Group();

        // ÊèêÁÅØÊú¨‰Ωì
        const bodyGeometry = new THREE.SphereGeometry(size, 16, 16);
        bodyGeometry.scale(1, 1.3, 1);
        const bodyMaterial = new THREE.MeshPhongMaterial({
          color: color,
          emissive: glowColor,
          emissiveIntensity: 0.6,
          shininess: 30,
          transparent: true,
          opacity: 0.85,
        });
        const body = new THREE.Mesh(bodyGeometry, bodyMaterial);
        lantern.add(body);

        // Ê®™„ÅÆÂ∏Ø
        for (let i = 0; i < 3; i++) {
          const bandGeometry = new THREE.TorusGeometry(
            size * 1.02,
            size * 0.08,
            8,
            24
          );
          const bandMaterial = new THREE.MeshPhongMaterial({
            color: 0x8b4513,
            shininess: 20,
          });
          const band = new THREE.Mesh(bandGeometry, bandMaterial);
          band.rotation.x = Math.PI / 2;
          band.position.y = (i - 1) * size * 0.6;
          lantern.add(band);
        }

        // ‰∏äÈÉ®„ÅÆË£ÖÈ£æ
        const topGeometry = new THREE.CylinderGeometry(
          size * 0.3,
          size * 0.5,
          size * 0.4,
          16
        );
        const topMaterial = new THREE.MeshPhongMaterial({
          color: 0x8b4513,
          shininess: 40,
        });
        const top = new THREE.Mesh(topGeometry, topMaterial);
        top.position.y = size * 1.5;
        lantern.add(top);

        // ‰∏ãÈÉ®„ÅÆË£ÖÈ£æ
        const bottomGeometry = new THREE.CylinderGeometry(
          size * 0.5,
          size * 0.3,
          size * 0.4,
          16
        );
        const bottom = new THREE.Mesh(bottomGeometry, topMaterial);
        bottom.position.y = -size * 1.5;
        lantern.add(bottom);

        // „Çø„ÉÉ„Çª„É´
        const tasselGeometry = new THREE.CylinderGeometry(
          0.02,
          size * 0.15,
          size * 0.8,
          8
        );
        const tasselMaterial = new THREE.MeshPhongMaterial({
          color: 0xff6b6b,
          shininess: 50,
        });
        const tassel = new THREE.Mesh(tasselGeometry, tasselMaterial);
        tassel.position.y = -size * 1.9;
        lantern.add(tassel);

        // ÂÜÖÈÉ®„ÅÆÂÖâÊ∫ê
        const light = new THREE.PointLight(glowColor, 2, size * 8);
        light.position.set(0, 0, 0);
        lantern.add(light);

        // „Ç∞„É≠„ÉºÂäπÊûú
        const glowGeometry = new THREE.SphereGeometry(size * 1.2, 16, 16);
        const glowMaterial = new THREE.MeshBasicMaterial({
          color: glowColor,
          transparent: true,
          opacity: 0.2,
          blending: THREE.AdditiveBlending,
        });
        const glow = new THREE.Mesh(glowGeometry, glowMaterial);
        lantern.add(glow);

        return lantern;
      }

      // ÊèêÁÅØ„ÅÆÈÖçÁΩÆ
      const lanterns = [];
      const lanternColors = [
        { body: 0xffaa66, glow: 0xff8844 },
        { body: 0xff88aa, glow: 0xff6688 },
        { body: 0xffcc88, glow: 0xffaa44 },
        { body: 0xff99cc, glow: 0xff77aa },
        { body: 0xffbb77, glow: 0xff9944 },
        { body: 0xcc88ff, glow: 0xaa66ff },
      ];

      for (let i = 0; i < 40; i++) {
        const size = 0.5 + Math.random() * 0.8;
        const colorSet =
          lanternColors[Math.floor(Math.random() * lanternColors.length)];
        const lantern = createLantern(size, colorSet.body, colorSet.glow);

        lantern.position.x = (Math.random() - 0.5) * 60;
        lantern.position.y = Math.random() * 30 - 10;
        lantern.position.z = (Math.random() - 0.5) * 60;

        lantern.userData = {
          riseSpeed: 0.01 + Math.random() * 0.02,
          swaySpeed: 0.5 + Math.random() * 0.5,
          swayAmount: 0.3 + Math.random() * 0.5,
          swayOffset: Math.random() * Math.PI * 2,
          rotateSpeed: 0.1 + Math.random() * 0.2,
          initialY: lantern.position.y,
        };

        scene.add(lantern);
        lanterns.push(lantern);
      }

      // ÂÖâ„ÅÆÁ≤íÂ≠ê
      const particleGeometry = new THREE.BufferGeometry();
      const particleCount = 300;
      const particlePositions = new Float32Array(particleCount * 3);
      const particleColors = new Float32Array(particleCount * 3);

      for (let i = 0; i < particleCount; i++) {
        const i3 = i * 3;

        particlePositions[i3] = (Math.random() - 0.5) * 80;
        particlePositions[i3 + 1] = Math.random() * 50 - 10;
        particlePositions[i3 + 2] = (Math.random() - 0.5) * 80;

        const colors = [0xffaa66, 0xff88aa, 0xffcc88, 0xff99cc];
        const color = new THREE.Color(
          colors[Math.floor(Math.random() * colors.length)]
        );
        particleColors[i3] = color.r;
        particleColors[i3 + 1] = color.g;
        particleColors[i3 + 2] = color.b;
      }

      particleGeometry.setAttribute(
        "position",
        new THREE.BufferAttribute(particlePositions, 3)
      );
      particleGeometry.setAttribute(
        "color",
        new THREE.BufferAttribute(particleColors, 3)
      );

      const particleMaterial = new THREE.PointsMaterial({
        size: 0.15,
        vertexColors: true,
        transparent: true,
        opacity: 0.7,
        blending: THREE.AdditiveBlending,
      });

      const particles = new THREE.Points(particleGeometry, particleMaterial);
      scene.add(particles);

      function animate() {
        requestAnimationFrame(animate);

        const t = performance.now() * 0.001;

        // ÊèêÁÅØ„ÅÆÂãï„Åç
        lanterns.forEach((lantern, index) => {
          const data = lantern.userData;

          // ‰∏äÊòá
          lantern.position.y += data.riseSpeed;

          // Êè∫„Çå
          const sway = Math.sin(t * data.swaySpeed + data.swayOffset);
          lantern.position.x += sway * 0.01 * data.swayAmount;
          lantern.position.z +=
            Math.cos(t * data.swaySpeed + data.swayOffset) *
            0.01 *
            data.swayAmount;

          // ÂõûËª¢
          lantern.rotation.y += data.rotateSpeed * 0.01;

          // ÁîªÈù¢Â§ñ„Å´Âá∫„Åü„Çâ„É™„Çª„ÉÉ„Éà
          if (lantern.position.y > 40) {
            lantern.position.y = -10;
            lantern.position.x = (Math.random() - 0.5) * 60;
            lantern.position.z = (Math.random() - 0.5) * 60;
          }

          // „Ç∞„É≠„Éº„ÅÆËÑàÂãï
          const glow = lantern.children[lantern.children.length - 1];
          const pulse = Math.sin(t * 2 + index * 0.5) * 0.5 + 0.5;
          glow.material.opacity = 0.1 + pulse * 0.15;
          const scale = 1 + pulse * 0.1;
          glow.scale.set(scale, scale, scale);
        });

        // Á≤íÂ≠ê„ÅÆÂãï„Åç
        const particlePos = particleGeometry.attributes.position.array;
        for (let i = 0; i < particleCount; i++) {
          const i3 = i * 3;
          particlePos[i3 + 1] += 0.03;
          particlePos[i3] += Math.sin(t + i * 0.1) * 0.02;
          particlePos[i3 + 2] += Math.cos(t + i * 0.1) * 0.02;

          if (particlePos[i3 + 1] > 40) {
            particlePos[i3 + 1] = -10;
            particlePos[i3] = (Math.random() - 0.5) * 80;
            particlePos[i3 + 2] = (Math.random() - 0.5) * 80;
          }
        }
        particleGeometry.attributes.position.needsUpdate = true;

        // „Ç´„É°„É©„ÅÆÂãï„Åç
        camera.position.x = Math.sin(t * 0.1) * 8;
        camera.position.z = 20 + Math.cos(t * 0.1) * 5;
        camera.position.y = 5 + Math.sin(t * 0.15) * 3;
        camera.lookAt(0, 5, 0);

        renderer.render(scene, camera);
      }
      animate();

      window.addEventListener("resize", () => {
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
        renderer.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
